### 📅 2024년 4월 3일

# 📚 4장 서버 사이드 렌더링

### p.263

- 싱글 페이지 애플리케이션과 서버에서 페이지를 빌드하는 서버 사이드 렌더링의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐다.
- 싱글 페이지 애플리케이션은 사용자에게 제공되는 타입스크립트 번들에서 렌더링을 담당한다.
- 서버 사이드 방식을 채택하면 렌더링에 필요한 작업을 모두 서버에서 수행한다.

### p.264~267

## 서버 사이드 렌더링의 장점

- 최초 페이지 진입이 비교적 빠르다.
  - 일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르고, 또 HTML을 그리는 작업도 서버에서 해당 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 더 빠르기 때문이다.
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
  - 서버 사이드 렌더링은 최초의 렌더링 작업이 서버에서 일어난다. 즉, 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화에 대응하기가 매우 용이하다.
- 누적 레이아웃 이동이 적다.
  - 누적 레이아웃 이동이란 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.
- 사용자의 디바이스 성능에 비교적 자유롭다.
  - 서버 사이드 렌더링을 수행하면 부담을 서버에 나눌 수 있기 때문이다.
- 보안에 좀 더 안전하다.
  - 서버 사이드 렌더링의 경우 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다는 장점이 있다.

## 서버 사이드 렌더링의 단점

- 소스코드를 작성할 때 항상 서버를 고려해야 한다.
- 적절한 서버가 구축돼 있어야 한다.
- 서비스 지연에 따른 문제.

### p.270~278

## 서버 사이드 렌더링을 위한 리액트 API 살펴보기

### renderToString

- 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수다.
- 클라이언트에서 실행되지 않고 일단 먼저 완성된 HTML을 서버에서 제공할 수 있으므로 초기 렌더링에서 뛰어난 성능을 보인다.

### renderToStaticMarkup

- renderToString과 유사한 함수로 두 함수 모두 리액트 컴포넌트를 기준으로 HTML 문자열을 만든다는 점에서 동일하다.
- 리액트의 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 만들 때만 사용된다.

### renderToNodeStream

- renderToString과 결과물이 완전히 동일하지만 두 가지 차이점이 있다.
- 위 두 API는 브라우저에서도 실행할 수 있지만 renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능하다.
- renderToString의 결과물은 string인 문자열이지만, renderToNodeStream의 결과물은 Node.js의 ReadableStream이다. utf-8로 인코딩된 바이트 스트림으로 Node.js나 Deno, Bun 같은 서버 환경에서만 사용할 수 있다.
- renderToString이 생성하는 HTML 결과물의 크기가 매우 크다면 이렇게 크기가 큰 문자열을 한번에 메모리에 올려두고 응답을 수행해야 해서 Node.js가 실행되는 서버에 큰 부담이 될 수 있는데 스트림을 활용하면 큰 크기의 데이터를 청크(chunk, 작은 단위)로 분리해 순차적으로 처리할 수 있다는 장점이 있다.
- 대부분의 널리 알려진 리액트 서버 사이드 렌더링 프레임워크는 모두 renderToString 대신 renderToNodeStream을 채택하고 있다.

### renderToStaticNodeStream

- renderToStaticMarkup과 마찬가지로 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다.
- 마찬가지로 hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드다.

### hydrate

- renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
- render와의 차이점은 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트르 붙이는 작업만 실행한다.

### p.299

## \_app.tsx와 \_document.tsx의 차이점

- \_app.tsx가 애플리케이션 페이지 전체를 초기화하는 곳이라면, \_document.tsx는 애플리케이션의 HTML을 초기화하는 곳이다.
- \_app.tsx는 렌더링이나 라우팅에 따라 서버나 클라이언트에서 실행될 수 있지만, \_document는 무조건 서버에서실행된다. 따라서 \_document 파일에서 onClick과 같은 이벤트 핸들러를 추가하는 것은 불가능하다. 이벤트를 추가하는 것은 클라이언트에서 실행되는 hydrate의 몫이기 때문이다.
- getServerSideProps, getStaticProps 등 서버에서 사용 가능한 데이터 불러오기 함수는 사용할 수 없다.

### p.307

- Next.js는 서버 사이드 렌더링의 장점, 즉 사용자가 빠르게 볼 수 있는 최초 페이지를 제공한다는 점과 싱글 페이지 애플리케이션의 장점인 자연스러운 라우팅이라는 두 가지 장점을 갖고있다.

### p.310~319

## getStaticPaths와 getStaticProps

- 두 함수는 어떻나 페이지를 CMS(Contents Management System)나 블로그, 게시판과 같은 사용자와 관계없이 정적으로 결정된 페이지를 보여주고자 할 때 사용되는 함수다.
- 두 함수는 반드시 함께 있어야 사용할 수 있다.

```tsx
import { GetStaticPaths, GetStaticProps } from "next";

export const getStaticPaths: GetStaticPaths = async () => {
  return {
    // 이 페이지는 /post/1과 /post/2만 접근 가능하며 이외의 페이지는 404를 반환한다.
    paths: [{ params: { id: "1" } }, { params: { id: "2" } }],
    fallback: false,
  };
};

export const getStaticProps: GetStaticProps = async ({ params }) => {
  const { id } = params;

  const post = await fetchPost(id);

  // 예제에서는 id가 각각 1과 2로 제한돼 있기 때문에 fetchPost(1), fetchPost(2)를 기준으로 각각 함수의 응답 결과를 변수로 가져와 props의 { post }로 반환하게 된다.

  return {
    props: { post },
  };
};

export default function Post({ post }: { post: Post }) {
  // post로 페이지를 렌더링한다.
}
```

- getStaticPaths는 접근 가능한 주소를 정의하는 함수다.
- getStaticProps는 앞에서 정의한 페이지를 기준으로 해당 페이지로 요청이 왔을 때 제공할 props를 반환하는 함수다.

## getServerSideProps

- 앞선 두 함수가 정적인 페이지 제공을 위해 사용된다면, getServerSideProps는 서버에서 실행되는 함수이며 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.
- 이 함수가 있다면 Next.js는 꼭 서버에서 실행해야 하는 페이지로 분류해 빌드 시에도 서버용 자바스크립트 파일을 별도로 만든다.
- 이 함수는 사용자가 매 페이지를 호출할 때마다 실행되고, 이 실행이 끝나기 전까지는 사용자에게 어떠한 HTML도 보여줄 수 없다. 따라서 getServerSideProps 내부에서 실행하는 내용은 최대한 간결하게 작성하기 위해 꼭 최초에 보여줘야 하는 데이터가 아니라면 클라이언트에서 호출하는 것이 더 유리하다.
- getServerSideProps에는 반드시 해당 페이지를 렌더링하는 데 있어 중요한 역할을 하는 데이터만 가져오는 것이 좋다.
- 어떤 조건에 따라 다른 페이지로 보내고 싶다면 redirect를 사용할 수 있다.

# 📚 8장 좋은 리액트 코드 작성을 위한 환경 구축하기

### p.480

- 리액트 17 버전을 사용하고 있다면 import React 구문을 모두 확인한 후에 제거하는 것이 좋다.
- 웹팩에서 제공하는 트리쉐이킹 기능이 사용하지 않는 코드를 모두 삭제하기 때문에 결과적으로 완전히 동일하다 하더라도 import React를 제거하는 것이 여전히 유용하다.
- 왜냐하면 웹팩이 트리쉐이킹을 하는 데 걸리는 시간을 그만큼 줄일 수 있기 때문이다. 자연스럽게 빌드 속도 또한 빨라질 것이다.

### p.489~491

## ESLint와 Prettier

- Prettier는 코드의 포매팅을 도와주는 도구다. ESLint와 마찬가지로 코드르 정적 분석해서 문제를 해결한다는 점은 동일하지만, 두 패키지가 지향하는 목표는 다르다.
- ESLint는 코드의 잠재적인 문제가 될 수 있는 부분을 분석해 준다면, Prettier는 포매팅과 관련된 작업, 즉 줄바꿈, 들여쓰기, 작은따옴표와 큰따옴표 등을 담당한다.
- 자바스크립트에서만 작동하는 ESLint와는 다르게, Prettier는 자바스크립트뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에도 적ㄷ용 가능하다.
- 여기서 문제는 Prettier와 ESLint가 서로 충돌을 일으킬 수 있다는 것이다. 서로 규칙이 충돌되지 않게끔 규칙을 잘 선언하는 것과 자바스크립트나 타입스크립트는 ESLint에, 그 외에 파일(마크다운, YAML, JSON 등)은 모두 Prettier에 맡기는 해결 방법이 있다.
- 자바스크립트에 필요한 Prettier 관련 규칙은 모두 eslint-plugin-prettier를 사용한다. Prettier에서 제공하는 모든 규칙을 ESLint에서 사용할 수 있는 규칙으로 만들어둔 플러그인이다.

### p.503

- 리액트 컴포넌트에서 테스트하는 일반적인 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는 지 여부다. 이를 확인하는 방법은 크게 3가지가 있다.
  - getBy...: 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러 발생. 복수 개를 찾고 싶다면 getAllBy..를 사용.
  - findBy...: getBy...와 거의 유사하지만 Promise를 반환한다는 차이점이 있다. 즉, 비동기로 찾는다는 것을 의미하며, 기본값으로 1000ms의 타임아웃을 가지고 있고 두 개 이상이면 에러를 발생시키지만 복수 개를 찾고 싶다면 findAllBy..를 사용.
  - queryBy...: 인수의 조건에 맞는 요소를 반환하는 대신, 찾지 못한다면 null을 반환한다. getBy...와 findBy...는 찾지 못하면 에러를 발생시키기 때문에 찾지 못해도 에러를 발생시키고 싶지 않을 때 사용한다. 마찬가지로 복수 개를 찾으면 에러가 발생하며 복수 개를 찾고 싶다면 queryAllBy...를 사용하면 된다.

### p.507

- jest의 메서드들
  - beforeEach: 각 테스트(it)를 수행하기 전에 실행하는 함수.
  - describe: 비슷한 속성을 가진 테스트를 하나의 그룹으로 묶는 역할. 꼭 필요한 메서드는 아니지만 테스트 코드가 많아지고 관리가 어려워진다면 describe로 묶어서 관리하는 것이 편리하다. describe 내부에 describe를 또 사용할 수 있다.
  - it: test와 완전히 동일하며, test의 축약어(alias)다. 테스트 코드를 좀 더 사람이 일긱 쉽게 하기 위해서다. 한결 더 문어체같이 표현되어 읽기 쉬워진다.
  - testId: testId는 리액트 테스팅 라이브러리의 예약어로, get 등의 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용할 수 있다. HTML의 DOM 요소에 testId 데이터셋을 선언해 두면 테스트 시에 getByTestId, findByTestId 등으로 선택할 수 있다.

### p.512~513

- 동적 코드의 테스트 코드
  - setup 함수: 내부에서 컴포넌트를 렌더링하고, 또 테스트에 필요한 요소를 반환하고 이를 함수로 묶어 두었다.
  - userEvent.type: 사용자가 타이핑하는 것을 흉내 내는 메서드다. @testing-library/react에서 제공하는 fireEvent와 차이가 있다. userEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내 낸다. 대부분의 이벤트를 테스트할 때는 fireEvent로 충분하고 훨씬 더 빠르지만 특별히 사용자의 이벤트르 흉내 내야 할 때만 userEvent를 사용한다.
  - jest.spyOn: Jest가 제공하는 spyOn은 어떠한 특정 메서드를 오염시키지 않고 실행이 됐는지, 또 어떤 인수로 실행됐는지 등 실행과 관련된 정보만 얻고 싶을 때 사용한다. 작동 자체에는 영향을 미치지 않고 단순히 관찰하는 용도로만 사용한다.
  - mockImplementation: 해당 메서드에 대한 모킹(mocking) 구현을 도와준다. Jest를 실행하는 Node.js 환경에서는 window.alert가 존재하지 않으므로 해당 메서드를 모의 함수(mock)로 구현해야 하는데 이것이 바로 mockImplementation의 역할이다. 함수가 실행됐는지 등의 정보는 확인할 수 있도록 도와준다.

### p.516

- MSW(Mock Service Worker)는 Node.js나 브라우저에서 모두 사용할 수 있는 모킹 라이브러리로, 브라우저에서는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현한다.
- Node.js나 브라우저에서는 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행하고, 이 요청을 중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식이다.
- 이러한 방식은 fetch의 모든 기능을 그대로 사용하면서도 응답에 대해서만 모킹할 수 있으므로 fetch를 모킹하는 것이 훨씬 수월해진다.

### p.518

```tsx
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

- 테스트 코드를 시작하기 전에는 서버를 가동하고, 테스트 코드 실행이 종료되면 서버를 종료시킨다.
- server.resetHandlers() 코드는 앞에서 선언한 setupServer의 기본 설정으로 되돌리는 역할을 한다. 리셋하지 않으면 계속해서 실패하거나 성공하는 코드로 남아있을 것이므로 초기화했던 초깃값을 유지하는 것이다.

### p.519

- MSW를 사용한 fetch 응답 모킹과 findBy를 활용해 비동기 요청이 끝난 뒤에 제대로 된 렌더링이 일어났는지 기다린 후에 확인하는 것이다.
- 이 두가지만 염두에 둔다면 비동기 컴포넌트 테스트 또한 크게 다를 것이 없다.

### p.526~527

- 소프트웨어의 테스트에 대해 논할 때 테스트 커버리지라고 해서 해당 소프트웨어가 얼마나 테스트됐는지를 나타내는 지표가 있다. 테스트 커버리지가 높을 수록 좋고 꾸준히 테스트 코드를 작성하라는 것이다.
- 그러나 테스트 커버리지가 만능은 아니다. 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니다.
- TDD(Test Driven Development: 테스트 주도 개발)라고 하는 개발 방법론을 차용해서 테스트를 우선시하더라도 서버 코드와는 다르게 프런트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버해 테스트를 작성하기란 불가능하다.
- 따라서 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것이다. 예를 들어, 전자상거래 애플리케이션이라면 가장 신경 써야 할 것은 바로 결제일 것이다.
- 어떻게 순차적으로 실행되는지 확인한 다음, 순차적인 프로세스에 맞춰 테스트 코드를 작성하면 된다. 모두 사용자와 최대한 비슷한 입장에서 테스트를 작성하는 것이 필요하다.

### p.527~528

- 유닛 테스트(Unit Test): 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트(Integration Test): 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드(End to End Test): 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트
- 리액트 테스팅 라이브러리는 유닛 테스트 내지는 통합 테스트를 도와주는 도구이며, E2E 테스트를 수행하려면 Cypress같은 다른 라이브러리의 힘을 빌려야 한다.
- 유닛 테스트에서 통합 테스트, 엔드 투 엔드 테스트로 갈수록 테스트가 실패할 지점이 많아지고, 테스트 코드도 복잡해지며 테스트해야 할 경우의 수도 많아지고 테스트 자체를 구축하는 것도 어려워진다.
- 테스트할 수 있는 방법은 여러 가지가 있지만 테스트가 이뤄야 할 목표는 애플리케이션이 비즈니스 요구사항을 충족하는지 확인하는 것 한 가지뿐이다.
- 애플리케이션의 취약한 부분이 걱정된다면 조금씩 테스트 코드를 추가해보자. 조금씩, 그러나 핵심적인 부분부터 테스트 코드를 작성하다 보면 소프트웨어의 품질에 확신을 갖게 될 것이다.
