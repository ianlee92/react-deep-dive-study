### 📅 2024년 4월 3일

# 📚 4장 서버 사이드 렌더링

### 싱글 페이지 어플리케이션

- 렌더링과 라우팅에 필요한 대부분의 기능을 브라우저의 자바스크립트에 의존.
- 첫 페이지에서 모든 데이터를 불러오고 이후에 페이지 전환을 위한 모든 작업이 자바스크립트와 브라우저에서의 작업으로 이루어진다.
- 페이지를 불러온 이후에는 서버에서 html을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다. => "싱글 페이지" 어플리케이션
- html내부코드는 비어있다. 빈껍데기 상태의 html파일에서 자바스크립트코드를 실행하는 과정에서 페이지가 렌더링된다.
- 단점: 최초에 로딩속도가 느리다.
  - 사용자가 해당 페이지에 진입하고, 자바스크립트 리소스를 다운로드하고, http 요청을 수행한 이후에 이 결과를 가지고 화면을 렌더링해야한다.
- 장점: 최초 로딩 이후에는 서버를 거쳐 리소스를 받아올 일이 적어지므로 UX/UI에 이점.

### JAM 스택

- CSR이 널리 퍼지게 된 것은 단순히 사용자에게 더 좋은 UX를 제공할 수 있어서만은 아니다.
  - 이전에는 웹 어플리케이션을 만들기 위해 자바스크립트 이외에도 신경쓸 것이 많았다.
  - SSR방식에서는 서버에서 데이터가 채워진 상태의 html을 넘겨주어야했구나! 서버 의존성을 해결해주었다
- Javascript, API, Markup

### 서버사이드 렌더링

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식.
- 웹페이지를 렌더링하는 작업에 대한 책임이 서버에 있음
- 장점
  - 최초 페이지 진입이 (비교적) 빠르다.
  - 검색엔진 최적화, sns 공유 등 메타데이터 제공이 쉽다.
  - 누적 레이아웃 이동이 적다. 페이지의 모든 정보가 채워진 상태에서 사용자에게 서빙되므로
  - 사용자 디바이스 성능에 비교적 자유롭다.
  - 보안에 좀 더 안전하다.
- 단점
  - 소스코드를 작성할 때 항상 서버를 고려해야 한다.
  - 서버가 구축되어있어야 한다.
  - 서비스 지연에 따른 문제

> SSR도 모든 문제의 해결책이 될 수는 없다. 웹사이트의 설계와 목적, 우선순위에 따라 적절한 방법을 선택해야한다.

### 서버사이드 렌더링을 위한 리액트 API

- renderToString
  - 리액트 컴포넌트를 렌더링해 html문자열로 반환. 클라이언트에서 실행되는 자바스크립트 코드는 포함되어있지 않다. 브라우저가 빠르게 렌더링할 수 있는 html을 제공할뿐.
  - data-reactroot: 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역핧
- renderToStaticMarkup
  - renderToString과 유사하나 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다 -> 크기가 아주 약간 줄어든다.
  - 리액트에서 제공하는 useEffect와 같은 API를 실행할 수 없다. 리액트 기능이 필요없는 완전 순수한 html을 만들때만 사용한다. ex) 블로그 글, 상품의 약관 정보 등
- renderToNodeStream
  - Node환경에 의존한다. 브라우저에서 사용하는 것이 완전히 불가능하다.
  - 결과물의 타입이 ReadableStream
  - \*스트림: 큰 데이터를 다룰 때 데이터를 청크로 분할해 조금씩 가져오는 방식
  - 브라우저에 제공해야하는 큰 HTML을 작은 단위로 쪼개 연속적으로 작성함으로써 리액트 애플리케이션을 렌더링하는 Nodejs 서버의 부담을 덜 수 있다.
- renderToStaticNodeStream
  - renderToNodeSteam과 결과물은 동일하나, 리액트 관련 메소드는 사용할 수 없다.
- hydrate
  - renderToString, renderToNodeStream으로 생성된 html 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
  - 브라우저에서의 render와 비슷하다.
    - render: html과 컴포넌트를 인수로 받음 / html에 컴포넌트를 렌더링 / 이벤트 핸들러를 붙이는 작업
    - hydrate: 렌더링된 html과 컴포넌트를 인수로 받음 / 이벤트 핸들러를 붙이는 작업

### 서버사이드 렌더링 예제 프로젝트

- 페이지가 온전히 서버에서 만들어졌는지 확인하려면 소스보기를 통해 확인하면 된다.
- renderNodeStream과 renderToString의 차이는 어디까지나 서버에서만 존재한다.
- webpack.config.js: entry를 선언해 시작점을 선언하고, 필요한 파일과 그에 맞는 loader를 제공하고, 마지막으로 번들링에서 제외할 내용을 선언한 뒤 output으로 내보낸다.
- 설정파일을 추출하는 명령어 - **eject**
- API 요청이 서버와 클라이언트 두 군데에서 일어난다면, API 결과에 따라 결과물이 달라질 수 있지 않을까?

## Nextjs 톺아보기

### 파일 구조

- package.json
- next.config.js
  - `/** @type {import('next').NextConfig} */`: 타입 도움을 받기위한 코드
  - reactStrictMode: 리액트 애플리케이션 내부에서 잠재적인 문제를 개발자에게 알리기 위한 도구
  - swcMinify: SWC를 기반으로 최소화 작업을 할 것인가?
    - SWC: 번들링과 컴파일을 빠르게 수행하기위한 도구. 바벨의 대안.
    - 러스트라는 언어로 만들어졌다.
    - 14에서부터 default = true
- \_app.tsx: 전체 페이지의 시작점. Nextjs를 초기화하는 파일.
  - 에러바운더리
  - reset.css와 같은 전역 css 선언
  - 최초에는 서버사이드렌더링. 이후에는 클라이언트에서 \_app.tsx의 렌더링이 실행된다.
- \_document.tsx: html설정과 관련된 코드를 추가하는 곳
  - 무조건 서버에서 실행된다.
  - css in js의 스타일을 서버에서 모아 html로 제공하는 작업
- \_error.tsx: 클라이언트 또는 서버에서 발생하는 500에러를 처리하는 페이지
  - 개발모드에서는 이 페이지로 이동하지 않고 개발자 에러 팝업이 뜬다.
- 404.tsx
- 500.tsx: 서버에서 발생하는 에러 핸들링
- index.tsx: 파일명들이 라우팅 구조로 구성된다.

- a태그 대신 Link를 사용하자.
- window.location.push 대신 router.push를 사용하자.
- ⬆️ 단, getServerSideProps가 존재하는 파일일 경우만 유효한 효과를 보인다.

- api/hello.ts: 서버의 API를 정의하는 폴더
  - 서버에서 내려주는 데이터를 조합해 BFF 형태로 활용
  - CORS를 우회하는 용도로 사용될 수 있다.

### DataFetching

- 서버사이드 렌더링을 지원하기 위한 데이터 불러오기 방식

  - getStaticPaths / getStaticProps
    - 정적인 페이지를 보여주는 데 사용.
    - getStaticPaths: 접근 가능한 주소를 지정. 이 함수에서 정의하지 않은 url로 접근할 시 404를 반환한다.
      - fallback: 미리 빌드해야 한 페이지가 너무 많은 경우.
    - 사용자가 접근할 수 있는 페이지를 미리 빌드해둠으로써 사용자는 페이지가 렌더링되는 것을 기다릴 필요가 없어진다.
  - getServerSideProps

    - 페이지 진입 전 실행되는 함수.
    - json으로 직렬화할 수 없는 값은 props로 내려줄 수 없다.
    - redirect를 사용할 수 있다.
    - 서버사이드 렌더링 작동 순서

      1. 서버에서 fetch 등으로 필요한 데이터를 가져온다.
      2. html을 완성한다.
      3. 완성된 html을 브라우저에 전달한다.
      4. hydrate 작업을 진행한다.
      5. hydrate의 결과물과 서버에서 만든 html이 다르면 에러를 뱉는다.
      6. 위 작업에서도 fetch를 이용해 데이터를 가져와야 한다.

      위에서 fetch 시점의 차이로 인한 결과물의 불일치가 발생할 수 있으므로 1번 fetch에서 가져온 정보를 html결과물 내에 script형태로 내려준다.6번에서는 재요청을 보내는 대신 script를 읽는다.

  - getInitialProps

### 스타일 적용하기

- 전역 스타일
- 컴포넌트 레벨 css - [name].module.css
- scss, sass
- css in js

# 📚 8장 좋은 리액트 코드 작성을 위한 환경 구축하기
