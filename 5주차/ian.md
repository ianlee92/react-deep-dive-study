### 📅 2024년 4월 17일

# 📚 9장 모던 리액트 개발 도구로 개발 및 배포 환경 구축하기

### p.532

- npm 설정을 package.json에서 하는 것처럼 타입스크립트 설정은 tsconfig.json에 기록한다.

```tsx
{
  "$schema": "https://json.schemastore.org/tsconfig.json"
}
```

- JSON 최상단에 $schema 키와 위와 같은 값을 넣으면 schemaStore에서 제공해주는 정보로, 해당 JSON 파일이 무엇을 의미하는지, 또 어떤 키와 어떤 값이 들어갈 수 있는지 알려준다.

### p.534~538

## tsconfig.json

- CompilerOptions는 타입스크립트를 자바스크립트로 컴파일할 때 사용하는 옵션이다.
- target: 타입스크립트가 변환을 목표로 하는 언어의 버전.
- lib: esnext를 추가하면 target은 es5라 할지라도 신규 기능에 대한 API 정보를 확인할 수 있게 되어 에러가 발생하지 않는다. dom을 추가하면 window, documnet 등 브라우저 위주의 API에 대한 명세를 사용할 수 있게 된다.
- strickNullChecks: 엄격한 널 검사를 활성화한다. 이 옵션을 켜면 null과 undefined를 명확하게 구분해 사용할 수 있게 된다.
- strictBindCallApply: 함수에 대해 사용할 수 있는 call, bind, apply에 대해 정확한 인수를 요구하는 옵션이다.
- noImplicitAny: 타입을 명시하지 않은 변수에 any를 넣지 않고 에러를 발생한다.
- noEmit: 컴파일을 하지 않고, 타입 체크만 한다. Next.js는 swc가 타입스크립트 파일을 컴파일하므로 굳이 타입스크립트가 자바스크립트로 컴파일할 필요가 없다. 이 옵션이 켜져 있으면 타입스크립트는 단순히 타입 검사만 하는 역할을 한다.
- module: 모듈 시스템 설정. commonjs는 require를 사용하고, esnext는 import를 사용한다.
- jsx: .tsx 파일 내부에 있는 JSX를 어떻게 컴파일할지 설정한다.
  - react: 기본값이며 React.creatElement로 변환한다. 리액트 16까지 기본적인 변환 방식이다.
  - react-jsx: 리액트 17에서 새롭게 등장한 방식으로, react/jsx-runtime을 사용해 변환한다. React.createElement를 사용하지 않아 import React from 'react'를 컴포넌트 상단에 적지 않아도 된다.
  - react-jsxdev: react-jsx와 동일하지만 디버깅 정보가 추가된다.
  - preserve: 변환하지 않고 그대로 유지한다.
- baseUrl: 모듈을 찾을 때 기준이 되는 디렉터리를 지정한다. 이 설정은 paths와 함께 사용된다.
- paths: 상대 경로는 파일이 많아지고 구조가 복잡해질수록 중첩되면서 읽기 어려워진다. 이러한 경로를 별칭(alias)을 지정할 수 있다.
- include: 타입스크립트 컴파일 대상에서 포함시킬 파일 목록을 의미한다.
- exclude: 타입스크립트 컴파일 대상에서 제외시킬 파일 목록을 의미한다. (node_modules)

### p.548

- CI: 코드의 변화를 모으고 관리하는 코드 중앙 저장소에서 여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정.
- 과거 이 CI 환경을 구축하기 위해 가장 자주 쓰인 솔루션은 젠킨스(Jenkins)다. 기본적으로 설치형 솔루션이기 때문에 별도 서버를 구축해야 하고, 서버 내에서 젠킨스를 설치해야 하고, 또 젠킨스를 사용 중인 저장소와 연결하는 작업을 해야만 했다. 설치 및 유지보수가 번거롭다는 단점이 있다.
- 이러한 젠킨스의 대안으로 떠오르고 있는 것이 바로 깃허브 액션이다. 깃허브에서 출시한 SaaS.
- 젠킨스는 구축에 어려움이 있지만 한번 잘 구축한 젠킨스 CI 파이프라인으로는 단순히 한 저장소의 코드에 그치지 않고 많은 것들을 수행할 수 있으며, 자체 서버를 구축할 수 있다는 장점 덕분에 제환적인 환경에서도 구축할 수 있다.
- 그럼에도 깃허브 액션은 깃허브 저장소를 기반으로 CI를 구축하고자 할 때 매우 유용하게 사용할 수 있다. 저장소에 있는 코드만으로 테스트, 빌드, 정적 분석 등 CI에 필요한 대부분의 기능을 손쉽게 구현할 수 있어 하나의 저장소에서 빠르고 다양한 CI 환경을 구축하고자 하는 상황에서는 깃허브 액션이 훨씬 경제적이다.

### p.549

- 러너(runner): 파일로 작성된 깃허브 액션이 실행되는 서버. 특별히 지정되지 않으면 공용 깃허브 액션 서버를 이용한다.
- 액션(action): 러너에서 실행되는 하나의 작업 단위. yaml 파일로 작성된 내용을 하나의 액션으로 볼 수 있다.
- 이벤트(event): 깃허브 액션의 실행을 일으키는 이벤트. 필요에 따라 한 개 이상의 이벤트를 지정할 수 있고 특정 브랜치를 지정하는 이벤트도 가능하다.
  - pull_request: PR과 관련된 이벤트로 PR이 열리거나, 닫히거나, 수정되거나, 할당되거나, 리뷰 요청되는 등의 PR과 관련된 이벤트.
  - issues: 이슈와 관련된 이벤트로 이슈가 열리거나, 닫히거나, 삭제되거나, 할당되는 등 이슈와 관련된 이벤트.
  - push: 커밋이나 태그가 푸시될 때 발생하는 이벤트.
  - schedule: 저장소에서 발생하는 이벤트와 별개로 특정 시간에 실행되는 이벤트. 여기서 말하는 시간은 cron에서 사용되는 시간을 의미.
- 잡(jobs): 하나의 러너에서 실행되는 여러 스텝의 모음. 하나의 액션에서 여러 잡을 생성할 수 있다. 병렬로 실행된다.
- 스텝(steps): 잡 내부에서 일어나는 하나하나의 작업. 병렬로 일어나지 않는다.

### p.550

- 깃허브 액션을 작성하려면 저장소의 루트에 .github/workflows 폴더를 생성하고 내부에 파일을 작성하면 된다.
- 파일명은 마음대로 지정할 수 있으며, yaml 파일 작성을 위해 확장자는 .yml 또는 .yaml로 지정해야 한다.

### p.553~554

```yaml
# name은 액션의 이름. (필수 값 아니지만 액션 구별용)
name: chapter7 build
# 액션이 실행될 때 구별할 수 있는 타이틀명. (필수 값 X, 예제처럼 어떤 사람이 트리거했는지 정도 구별하는데 쓸 수 있음)
run-name: ${{ github. actor }} has been added new commit.

# 필수 값으로 언제 이 액션을 실행할지 정의한다. 예제에서는 원격 저장소의 푸시가 발생했을 때 실행하도록 함. (main 브랜치에 푸시가 발생했을 때는 실행 X)
on:
  push:
    branches-ignore:
      - "main"

# 필수 값으로 해당 액션에서 수행할 잡을 의미한다. 한 개 이상 설정할 수 있으며 여러 개를 지정하면 병렬로 실행된다.
jobs:
  # 임의로 지정한 이름(예약어X), name과 같은 역할. jobs의 하위 항목이므로 반드시 들여쓰기를 해야 함.
  build:
    # 어느 환경에서 해당 작ㄷ업이 실행될지 결정. 별도의 러너를 설정하고 싶지 않고 깃허브 제공하는 서버를 쓰고 싶다면 ubuntu-latest 선언.
    runs-on: ubuntu-latest
    # 해당 잡에서 순차적으로 수행할 작업 정의.
    steps:
      # 해당 스텝에서 작업을 actions/checkout@v3를 사용해서 작업하겠다는 것을 의미.
      # actions/checkout@v3은 깃허브에서 제공하는 기본 액션으로 별도 파라미터를 제공하지 않으면 해당 브랜치 마지막 커밋 기준으로 체크아웃.
      - uses: actions/checkout@v3
      # actions/setup-node@v3 역시 깃허브 기본 액션으로 해당 러너에 Node.js를 설치. 해당 프런트엔드 프로젝트가 배포되는 Node.js 버전에 맞춰 작성.
      - uses: actions/setup-node@v3
        with:
          node-version: 16
      # 해당 스텝의 명칭 지정. 의존성을 설치하는 작업 수행. working-directory는 터미널의 cd 명령과 비슷한 역할을 함. (그냥 루트에서 실행해도 된다면 지정하지 않아도 됨). run을 통해 수행할 작업 명시. 의존성 설치를 위해 npm ci 선언함.
      - name: "install dependencies"
        working-directory: ./chapter7/my-app
        run: npm ci
      # CI를 위한 작업, git checkout, Node.js 설치, 의존성 설치까지 마무리했으니 마지막 작업으로 빌드를 수행. Next.js 프로젝트 빌드.
      - name: "build"
        working-directory: ./chapter7/my-app
        run: npm run build
```

### p.568~570

- npm 버전 규칙

  - react@16.0.0: 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존하고 있다는 뜻.
  - react@^16.0.0: 16.0.0과 호환되는 버전을 의미한다. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정하에 상위 버전을 설치할 수 있다는 뜻. 즉, 가능한 버전은 16.0.0부터 17.0.0 미만의 모든 버전.
  - react@~16.0.0: 패치 버전에 대해서만 호환되는 버전을 의미한다. 즉, 가능한 버전은 16.0.0부터 16.1.0 미만의 모든 버전.

- 의존성
- dependencies: package.json에서 npm install을 실행하면 설치되는 의존성이며, npm install 패키지명을 실행하면 dependencies에 추가된다. 해당 프로젝트를 실행하는 데 꼭 필요한 패키지가 여기에 선언됨.
- devDependencies: package.json에서 npm install을 실행하면 설치되는 의존성이며, npm install 패키지명 --save-dev를 실행하면 devDependencies에 추가된다. 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 빌표한 패키지들을 여기에 선언한다.
- peerDependencies: 주로 서비스보다는 라이브러리와 패키지에 자주 쓰이는 단위. 직접적으로 해당 패키지를 require하거나 import하지는 않지만 호환성으로 인해 필요한 경우를 의미함.

- 최근에는 애플리케잇녀 실행에 필요한 패키지를 구분하는 것에 의문을 제기하는 목소리도 있다.
- 첫 번째 이유는 번들러의 존재. devDependencies로 설치한 것이든 dependencies로 설치한 것이든 모두 node_modules에 동일하게 설치한다. 실제로 이 중에서 실제 서비스에 배포해야 하는 라이브러리인지 결정하는 것은 번들러고 필요한 파일을 빌드 과정을 거쳐 하나의 결과물로 만들어 최종 결과물에 전혀 영향을 미치지 않는 것.
- 두 번째 이유는 복잡해진 개발 파이프라인. 과거와 달리 둘의 경계가 프런트엔드 애플리케이션의 경우 모호해지고 있어 둘을 구분하지 않고 모두 dependencies에 몰아넣고 관리하는 경우도 있다.
- 하지만 npm에 업로드할 패키지를 개발한다면 이러한 두 의존성의 구분은 매우 중요하다. (dependencies에 있는 패키지들만 모두 최종 패키지 결과물에 포함되게 해야 한다.)

### p.617

- 과거에는 웹 애플리케이션을 배포하기 위해 직접 장비를 준비하고, 해당 장비에 애플리케이션 구동에 필요한 각종 파일을 설치하고 소스를 다운로드해서 설치했다면 요즘은 애플리케이션을 하나의 컨테이너로 만들어서 빠르게 배포하는 것이 일반적이다.
- 이 컨테이너를 만드는 데 사용되는 것이 바로 도커(Docker)다. 도커는 서비스 운영에 필요한 애플리케이션을 격리해 컨테이너로 만드는데 이용하는 소프트웨어다.
- 이렇게 어디서든 실행될 수 있는 이미지 상태로 애플리케이션을 준비해 둔다면 이 도커 이미지를 실행할 수 있는 최소한의 환경이 갖춰진 상태라면 어디서든 웹 애플리케이션을 배포할 수 있다.
- 즉, 서비스를 Vercel, Netlify와 같이 특정 배포 서비스에 종속적이지 않은 상태로 만들어 좀 더 유연하게 관리할 수 있다.
