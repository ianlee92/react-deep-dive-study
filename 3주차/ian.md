### 📅 2024년 3월 27일

# 📚 6장 리액트 개발 도구로 디버깅하기

### p.402~403

- 리액트 개발자 도구의 아이콘이 회색으로 표시된다면 리액트 개발자 도구를 활용할 수 없는 페이지라는 뜻이다.
- 빨간색으로 표시된다면 현재 웹페이지가 리액트 개발자 모드로 실행되고 있다는 뜻이며 원래의 리액트 색상으로 표시된다면 리액트 프로덕션 모드로 빌드되어 실행되고 있다는 뜻이다.

### p.403

- 크롬 개발자 도구에 리액트 개발 도구를 설치하면 Components와 Profiler가 추가된 것을 확인할 수 있다.
- 이 두 탭이 바로 리액트 개발자 도구에서 제공하는 디버그 도구다.

### 컴포넌트 (p.403~416)

- Components 탭에서는 현재 리액트 애플리케이션의 컴포넌트 트리를 확인할 수 있다.
- 단순히 컴포넌트의 구조뿐만 아니라 props와 내부 hooks 등 다양한 정보를 확인할 수 있다.
- 컴포넌트 트리

  - Components의 왼쪽 영역은 해당 리액트 페이지의 컴포넌트 트리를 나타낸다.
  - 기명 함수로 선언되어 컴포넌트명을 알 수 있다면 해당 컴포넌트명을 보여주고, 만약 익명 함수로 선언돼 있다면 Anonymous라는 이름으로 컴포넌트를 보여준다.
  - 익명 함수를 default로 export한 경우, memo를 사용해 익명 함수로 만든 컴포넌트를 감싼 경우, 고차 컴포넌트로 감싼 HOCComponent의 경우 모두 Anonymous로 선언돼 있다.
  - 컴포넌트를 기명 함수로 선언하는 것은 개발 도구에서 확인하는 데 많은 도움을 준다.
  - 만약 함수를 기명 함수로 바꾸기 어렵다면 함수에 displayName 속성을 추가하는 방법도 있다.

    ```tsx
    const MemoizedComponent = memo(function () {
      return <>MemoizedComponent</>;
    });

    MemoizedComponent.displayName = "메모 컴포넌트입니다.";
    ```

- 컴포넌트명과 props
  - 왼쪽 컴포넌트 트리에서 컴포넌트르 선택했을 때 오른쪽은 해당 컴포넌트에 대한 자세한 정보를 보여주는 영역이다.
  - 해당 컴포너트가 받은 props를 확인할 수 있고 단순한 원시값뿐만 아니라 함수도 포함돼 있다.
  - 컴포넌트에서 사용 중인 훅 정보는 use가 생략된 이름으로 나타난다. (ex: useState -> State, useEffect -> Effect)
  - 리액트에서 제공하는 훅이 아닌 경우 즉, 사용자 정의 훅도 useXXX로 선언돼 있다면 use가 생략된 이름으로 나타난다. (ex: useCounter -> Counter)
  - 대부분 useEffect에는 익명 함수를 인수로 넘겨주기 때문에 여러 개 선언돼 있다면 어떤 훅인지 구별이 어렵기에 기명 함수로 선언하면 개발 도구를 더욱 유용하게 이용할 수 있다.
  - rendered by는 해당 컴포넌트를 렌더링한 주체가 누구인지 확인할 수 있다. 프로덕션 모드에서는 react-dom의 버전만 확인 가능하지만, 개발 모드에서는 해당 컴포넌트를 렌더링한 부모 컴포넌트까지 확인할 수 있다.

### 프로파일러 (p.417~430)

- 컴포넌트 메뉴가 정적인 현재 리액트 컴포넌트 트리의 내용을 디버깅하기 위한 도구라면 프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구다.
- 즉 리액트 애플리케이션이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지 등 컴포넌트 렌더링 과정에서 발생하는 일을 확인할 수 있다.
- 렌더링 과정에 개입해 디버깅에 필요한 내용을 기록해야 하기 때문에 프로덕션 빌드로 실행되는 리액트 애플리케이션에서는 사용할 수 없다.
- General 탭의 Highlight updates when components render: 컴포넌트가 렌더링될 때마다 해당 컴포넌트에 하이라이트를 표시.
- 프로파일링
  - 첫 번째 버튼 Start Profiling(프로파일링 시작) 버튼을 누르면 프로파일링이 시작되고 적색 동그라미로 바뀌며 다시 누르면 프로파일링이 중단되고 결과가 나타난다.
  - 두 번째 버튼 Reload and Start profiling(새로고침 후 프로파일링 시작)은 위와 유사하지만 웹페이지가 새로고침되면서 동시에 프로파일링이 시작된다.
  - 세 번째 버튼 Stop Profiling(프로파일링 종료) 버튼은 프로파일링된 현재 내용을 모두 지우는 버튼으로 기록을 모두 삭제할 수 있다.
  - 네 번째, 다섯 번째 버튼은 Load Profile(프로파일 불러오기), Save Profile(프로파일 저장하기) 버튼으로 프로파일링 결과를 저장하고 불러온느 버튼이다.
    - 사용자의 브라우저에 해당 프로파일링 정보가 담긴 JSON 파일이 다운로드되며 다시 로딩해 프로파일링 정보를 불러올 수도 있다.
- Flamegraph탭은 불꽃 모양의 아이콘을 가진 탭으로 렌더 커밋별로 어떠한 작업이 일어났는지 나타낸다. 너비가 넓을수록 해당 컴포넌트를 렌더링하는 데 오래 걸렸다는 의미다.
- 노란색에 가까울수록 렌더링에 오래 걸린 컴포넌트이며, 녹색에 가까울수록 빠르게 렌더링된 컴포넌트다. 회색으로 표시된 컴포넌트는 아예 렌더링되지 않은 컴포넌트다.
- Ranked는 해당 커밋에서 렌더링하는 데 오랜 시간이 걸린 컴포넌트를 순서대로 나열한 그래프다. 렌더링되지 않은 정보는 필터링해서 보여주기 때문에 좀 더 간결하게 원하는 정보를 파악할 수 있다.
- Timeline은 시간이 지남에 따라 컴포넌트에서 어떤 일이 일어났는지를 확인할 수 있다. 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는 데 유용하다.
- 렌더링 정보에 대해 확인하려면 우측 상단 그래프에서 오른쪽 화살표를 누르거나 보고 싶은 커밋을 클릭해 "What caused this update?"를 눌러 해당 컴포넌트가 렌더링된 이유를 살펴볼 수 있다.

### p.430

- 리액트 개발 도구를 활용하면 정적으로 생성된 컴포넌트 트리를 보는 것에서부터 프로파일링을 통해 리액트 애플리케이션이 시간이 지남에 따라 어떤 식으로 작동하는지, 불필요한 리렌더링이 일어나고 있는지 등을 확인할 수 있다.

### p.431

- 리액트 컴포넌트 구조가 복잡해지기 전에 틈틈이 리액트 개발 도구를 활용해 디버깅을 수행해 하는 것이 좋다.
- 개발이 완성된 애플리케이션에 무작정 개발 도구를 열어본다면 생각보다 많은 시간이 소요되고 한눈에 내용을 파악하기도 어려워 거부감을 느낄 수도 있다.

# 📚 7장 크롬 개발자 도구를 활용한 애플리케이션 분석

### p.433

- 크롬 개발자 도구에서 웹사이트를 제대로 디버깅하고 싶다면 시크릿 모드 또는 프라이빗 모드라 불리는 개인정보 보호 모드에서 페이지와 개발자 도구를 여는 것을 권장한다.
- 그 이유는 바로 브라우저에 설치돼 있는 각종 확장 프로그램 때문에 디버깅하는 데 방해가 될 수 있기 때문이다.

### p.434

- 크롬 개발자 도구에서 첫 번째로 노출되는 요소(Element) 탭에서는 현재 웹페이지를 구성하고 있는 HTML, CSS 등의 정보를 확인할 수 있다.

### p.444

- 생각 이상으로 리소스 크기가 크다면 gzip이나 brotli를 적절히 활용해 리소스를 압축하거나 이미지가 있다면 이미지를 최적화할 필요도 있다.

### p.445

- 네트워크 탭을 통해 웹페이지 로딩 과정 중 발생하는 네트워크 요청을 확인한다.
  - 불필요한 요청 또는 중복되는 요청이 없는지, 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
  - 리소스를 불러오는 속도는 적절한지 또는 너무 속도가 오래 걸리는 리소스는 없는지
  - 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

### 메모리 탭 (p.445~461)

- 메모리 탭에서는 현재 웹페이지가 차지하고 있는 메모리 관련 정보를 확인할 수 있다.
- 애플리케이션에서 발생하는 메모리 누수, 속도 저하, 혹은 웹페이지 프리징 현상을 확인할 수 있는 유용한 도구다.

- 힙 스냅샷: 스냅샷이라는 이름에 걸맞게 현재 메모리 상황을 사진 찍듯이 촬영할 수 있다. 현재 시점의 메모리 상황을 알고싶다면 힙 스냅샷을 활용하면 된다.
- 타임라인의 할당 계측: 현재 시점의 메모리 상황이 아닌, 시간의 흐름에 따라 메모리의 변화를 살펴보고 싶다면 타임라인의 할당 계측을 사용하면 된다. 주로 로딩이 되는 과정의 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용한다.
- 할당 샘플링: 메모리 공간을 차지하고 있는 자바스크립트 함수를 볼 수 있다.

- 스냅샷 촬영을 제대로 활용하려면 하나의 스냅샷을 가지고 파악하는 것보다 스냅샷을 두 개 이상을 촬영한 다음, 그 차이만 비교하는 것이 훨씬 수월하다.
- 익명 화살표 함수는 사용할 때는 간단하지만 디버깅할 때는 그다지 도움이 되지 않는다. 기명 함수로 바꾼다면 힙 스냅샷에서 바로 확인할 수 있다.

  ```tsx
  // 코드를 실행해서 개발자 도구에서 확인하면 기명 함수를 명확하게 확인할 수 있다.
  function handleToggle() {
    setToggle(function 토글함수(prev) {
      return !prev;
    });
  }
  ```

- 소스 탭이든, 현재 메모리 탭이든, 디버깅을 빠르고 원활하게 하려면 기명 함수를 사용하는 편이 좋다.
- 메모리 누수가 발생하는 것으로 예상되거나 혹은 위험이 존재할 것 같은 스크립트 전후로 내용을 촬영해 비교하는 것이 좋다.
- 원인을 더욱 정확하게 파악하려면 변수와 함수에 적절한 이름을 주어 수많은 메모리 내용 사이에서 눈에 띄게 하는 것이 큰 도움이 된다.

- 타임라인 할당 계측을 활용하면 시간의 흐름에 따른 메모리 변화를 비롯해 메모리 변화를 일으킨 변수가 무엇인지, 해당 변수가 어느 정도 크기를 차지하고 있는지 등을 확인할 수 있다.
- 할당 샘플링은 시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에서 타임라인 할당 계측과 비슷하지만 자바스크립트 실행 스택별로 분석할 수 있고, 이 분석을 함수 단위로 한다는 차이점이 있다.

- 할당 샘플링은 타임라인 할당 계측과 유사하지만 프로파일링할 때 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅을 수행해야 할 때 유리하다.
- 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인하기 어려워 힙 스냅샷을 촬영해 비교하기 어려운 경우, 오랜 기간 메모리 누수가 의심되어 프로파일링을 장기간 수행해야 하는 경우에는 할당 샘플링을 활용하는 것이 좋다.
