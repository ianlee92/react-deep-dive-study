### 📅 2024년 4월 24일

# 📚 10장 리액트 17과 18의 변경 사항 살펴보기

## 리액트 17

### p.657

- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다는 점을 가장 큰 특징으로 꼽는다.

### p.666~668

- 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었다.
- 그런데 리액트 17부터는 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다.
- 점진적인 업그레이드 지원, 그리고 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서다.
- 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경했다.

### p.670~671

- 16 버전까지는 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 import React from 'react'가 필요했고 이 코드가 없으면 에러가 발생했다.
- 리액트 17부터는 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다.
- import React가 필요 없다는 장점 외에도, 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있고 컴포넌트 작성을 더욱 간결하게 해준다.

### p.674

- 리액트의 useEffect에 있는 클린업 함수는 리액트 16 버전까지는 동기적으로 처리됐다.
- 동기적으로 실행되기 때문에 이 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하로 이어지는 문제가 존재했다.
- 리액트 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다.
- 클린업 함수는 컴포넌트의 커밋 단계가 완료될 때까지 지연된다. 즉, 화면이 업데이트가 완전히 끝난 이후에 실행되도록 바뀌어 약간의 성능적인 이점을 볼 수 있게 됐다.

## 리액트 18

### p.679

- 리액트 17에서 점진적인 업그레이드를 위한 준비를 했다면 리액트 18에서는 리액트 17에서 하지 못했던 다양한 기능들이 추가됐다.
- 그중 가장 큰 변경점은 바로 동시성 지원이다.
- 리액트 18에서는 리액트 16.8에서 처음 선보였던 이래로 새로운 훅을 대거 추가했다.

### p.679

- useId는 컴포넌트별로 유니크한 값을 생성하는 새로운 훅이다.
- 하나의 컴포넌트가 여러 군데에서 재사용되는 경우도 고려해야 하며, 리액트 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않고 다 달라야 한다는 제약도 있다.
- 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때도 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않으므로 이러한 점도 고려해야 한다.

### p.682, 685, 686

- useTransition 훅은 UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅이다.
- 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있으며, 사용자에게 조금 더 나은 사용자 경험을 제공할 수 있다.

```tsx
const [isPending, startTransition] = useTransition();
```

- useTransition은 아무것도 인수로 받지 않으며, isPending과 startTransition이 담긴 배열을 반환한다.
- isPending은 상태 업데이트가 진행 중인지를 확인할 수 있는 boolean이고, startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다. 여러 개의 setter를 넣어줄 수도 있다.
- useTransition은 리액트 18의 변경 사항의 핵심 중 하나인 '동시성(concurrency)'을 다룰 수 있는 새로운 훅이다.
- useTransition은 이름에서도 알 수 있듯 컴포넌트에서만 사용 가능한 훅이다.

### useTransition 사용할 때 주의할 점

- startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
  - 만약 props나 사용자 정의 훅에서 반환하는 값 등을 사용하고 싶다면 useDefferedValue를 사용하면 된다.
- startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다.
  - 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
- startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다.
  - setTimeout과 같은 비동기 함수를 넣으면 제대로 작동하지 않게 된다. startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업사이에 불일치가 일어나기 때문이다.

### p.689~690

- 과거 리액트에서는 중간에 데이터 업데이트가 일어나는 것과 상관없이 동기적으로 렌더링이 한 번에 발생해서 테어링(tearing) 현상이 없었다.
- 리액트 18에서부터는 리액트가 렌더링을 중지했다가 다시 실행하는 등 '양보'하는 것이 가능해졌기 때문에 이러한 문제 발생할 가능성이 존재한다.
- 리액트에서 관리하는 state라면 useTransition이나 useDefferedValue와 같이 내부적으로 해결하기 위한 처리를 해뒀지만 리액트에서 관리할 수 없는 외부 데이터 소스에서라면 문제가 달라진다.
- 외부 데이터 소스란 리액트 클로저 범위 밖에 있는 관리 범위 밖에 있는 값들을 말한다. 글로벌 변수, document.body, window.innerWidth, DOM, 리액트 외부에 상태를 저장하는 외부 상태 관리 라이브러리 등.
- 즉, useState나 useReducer가 아닌 모든 것들이 바로 외부 데이터 소스다.
- 외부 데이터 소스에 리액트에서 추구하는 동시성 처리가 추가돼 있지 않다면 테어링 현상이 발생할 수 있다.
- 이 문제를 해결하기 위한 훅이 바로 useSyncExternalStore다.

```tsx
import { useSyncExternalStore } from 'react'

useSyncExternalStore(
  subscribe: (callback) => Unsubscribe
  getSnapshot: () => State
) => State
```

- subscribe는 콜백 함수르 받아 스토어에 등록하는 용도로 사용된다. 스토어에 있는 값이 변경되면 콜백 호출되고 이 훅을 사용하는 컴포넌트 리렌더링.
- 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수. 스토어에서 값이 변경됐다면 Object.is로 비교해 정말로 값이 변경됐다면 컴포넌트 리렌더링.
- 마지막 인수는 옵셔널 값으로, 서버 사이드 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용된다. 서버 사이드에서 렌더링되는 훅이라면 반드시 이 값읅 넘겨줘야 한다.

```tsx
function subscribe(callback: (this: Window, ev: UIEvent) => void) {
  window.addEventListener("resize", callback);
  return () => {
    window.removeEventListener("resize", callback);
  };
}

function useWindowWidth() {
  return useSyncExternalStore(
    subscribe,
    () => window.innerWidth,
    () => 0
  );
}

export default function App() {
  const windowSize = useWindowWidth();
  return <>{windowSize}</>;
}
```

- useSyncExternalStore를 통해 현재 윈도우의 innerWidth를 확인하는 훅을 만들었다.
- innerWidth는 리액트 외부에 있는 데이터 값이므로 이 값의 변경 여부를 확인해 리렌더링까지 이어지게 하려면 useSyncExternalStore를 사용하는 것이 매우 적절하다.
- subscirbe 함수를 첫 번째 인수로 넘겨 innerWidth가 변겨여될 때 일어나는 콜백 등록. resize 이벤트가 발생할 때 마다 해당 콜백 실행.
- 두 번째 인수로는 현재 스토어의 값인 window.innerWidth, 마지막으로 서버 사이드에서는 해당 값을 추적할 수 없으므로 0을 제공.

### p.692~693

- useSyncExternalStore가 상태 관리 라이브러리를 위한 훅이라면 useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅이다.
- useInsertionEffect는 DOM이 실제로 변경되기 전에 동기적으로 실행된다.
- 리액트에서 권고하는 것처럼 useSyncExternalStore와 마찬가지로 useInsertionEffect는 실제 애플리케이션 코드를 작성할 때는 사용될 일이 거의 없으므로 라이브러리를 작성하는 경우가 아니라면 참고만 하고 실제 애플리케이션 코드에는 가급적 사용하지 않는 것이 좋다.

### p.712

- 리액트 18 버전에서는 Suspense가 실험 단계를 벗어나 정식으로 지원된다.
- Suspense의 사용이 이전보다 비교적 자연스러워졌지만 여전히 사용할 수 있는 시나리오는 제한적인 편이다.
- React.lazy를 사용해 컴포넌트를 지연시켜 불러오거나, Next.js와 같이 Suspense를 자체적으로 지원하는 프레임워크에서만 사용 가능하다.

### p.713

- 컴포넌트에서 undefined를 반환해도 에러가 발생하지 않는다. undefined 반환은 null 반환과 동일하게 처리된다.
- 이와 마찬가지로 <Suspense fallback={undefiend}>도 null과 동일하게 처리된다.
- renderToNodeStream이 지원 중단되고 그 대신 renderToPipeableStream을 사용하는 것이 권장된다.

### p.714

- 리액트 18 버전 업의 핵심은 동시성 렌더링이다.
- 렌더링 중간에 일시 중지한 다음, 나중에 여유가 될 때 다시 시작하거나, 진행 중인 렌더링 작업을 포기하고 새로 다시 시작할 수도 있다.

# 📚 11장 Next.js 13과 리액트 18

### p.715

- Next.js 버전 13은 Next.js의 릴리스 역사를 통틀어 가장 큰 변화가 있는 릴리스라고 해도 과언이 아니다.
- 서버 사이드 렌더링의 구조에 많은 변화가 있는 리액트 18을 채택했으며, 큰 약점으로 지적되던 레이아웃 지원을 본격적으로 지원하기 시작했다.
- 바벨을 대체할 러스트(Rust) 기반 SWC를 뒤이어 웹팩을 대체할 Turbopack까지 출시했다.

### p.719

- 기존에 /pages로 정의하던 라우팅 방식이 /app 디렉터리로 이동했다.
- Next.js 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다.
- app 디렉터리 내부의 폴더명이 라우팅이 되며 layout.js는 페이지의 기본적인 레이아웃을 구성하는 요소다.

### p.724~725

- error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.
- not-found.js는 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.
- loading.js은 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

### p.728~730

- 리액트의 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드 처리가 이뤄진다.
- 웹사이트를 방문하면 리액트 실행에 필요한 코드를 다운로드 -> 리액트 컴포넌트 트리 -> DOM에 렌더링한다.
- 서버 사이드 렌더링은 미리 서버에서 DOM 만들고 클라이언트에서는 이렇게 만들어진 DOM을 기준으로 하이드레이션을 진행한다.

## 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다.
- 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
- 자동 코드 분할(code split)이 불가능하다.
- 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.
- 추상화에 드는 비용이 증가한다.

### p.732

- 이렇게 서버 사이드 렌더링의 한계점을 쭉 살펴보면 모든 문제는 리액트가 클라이언트 중심으로 돌아가기 때문에 발생하는 문제라는 것을 알 수 있다.
- 서버 사이드 렌더링은 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터에 손쉽게 제공할 수 있다.
- 클라이언트 사이드 렌더링은 사용자의 인터렉션에 따라 정말 다양한 것들을 제공할 수 있다.
- 이러한 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트다.

### p.732~735

- 서버 컴포넌트(Server Component)란 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법을 의미한다.
- 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없다. 클라이언트 및 서버 컴포넌트가 혼재된 상황은 children으로 자주 사용되는 ReactNode에 달려 있다.

## 서버 컴포넌트

- 요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다. useState, useReducer 훅 사용 불가.
- 렌더링 생명주기도 사용할 수 없다. 한번 렌더링되면 그걸로 끝이기 때문이다. useEffect, useLayoutEffect 사용 불가.
- 위 두 가지 제약사항으로 인해 effect나 state에 의존하는 사용자 정의 훅 또한 사용할 수 없다.
- 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 DOM API를 쓰거나 window, document 등에 접근 불가.
- 데이터베이스, 내부 서비스, 파일 시스템 등 서버에만 있는 데이터를 async/awiat로 접근 가능. 컴포넌트 자체가 async한 것이 가능.
- 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나, 혹은 클라이언트 컴포넌트를 렌더링할 수 있다.

## 클라이언트 컴포넌트

- 브라우저 환경에서만 실행되므로 서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.
- 클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다.

  ```tsx
  <ClientComponent>
    <ServerComponent />
  </ClientComponent>
  ```

- 클라이언트 입장에서 봤을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고, 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입해서 보여주기만 하기 때문이다.

### p.735

- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다. 즉, 모든 컴포넌트를 다 서버에서 실행 가능한 것으로 분류한다.
- 대신, 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 파일의 맨 첫 줄에 "use client"라고 작성해 두면 된다.

### p.736

- 서버 사이드 렌더링은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 결과를 클라이언트에 내려준다.
- 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행한다.
- 서버 사이드 렌더링과 서버 컴포넌트는 대체제가 아닌 상호보완하는 개념으로 봐야 한다.

### p.738~740

## 서버 컴포넌트는 어떻게 작동하는가?

- 서버 컴포넌트는 서버가 렌더링 요청을 받는다. 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
- 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다.
- 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다.
- M으로 시작하는 줄은 클라이언트 컴포넌트, S는 Suspense, J는 서버에서 렌더링된 서버 컴포넌트다.
- @1, @2와 같은 요소는 나중에 렌더링이 완료됐을 때 들어가야 할 컴포넌트를 의미하는 것으로 @1은 M1이 렌더링되면 @1 자리에 @M1이 들어가야 한다는 것을 의미한다.
- 브라우저가 리액트 컴포넌트 트리를 구성하고 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다.
- 그리고 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다.

### p.740

- 서버 사이드 렌더링과 다르게 결과물이 HTML이 아닌 JSON 형태로 보내진 것을 주목해 볼 만하다.
- HTML 대신 단순한 리액트 컴포넌트 구조를 JSON으로 받아서 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와준다.

### p.741~743

- 과거 Next.js의 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getIntialProps가 /app 디렉터리 내부에서는 삭제됐다.
- 그 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.
- fetch API를 확장해 같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다.
- 요즘 인기를 끌고 있는 SWR과 React Query와 비슷하게 해당 fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

### p.747

## fetch 옵션

- fetch(URL, { cache: 'force-cache' }): 기본값으로 getStaticProps와 유사하게 불러온 데이터를 캐싱해 해당 데이터로만 관리한다.
- fetch(URL, { cache: 'no-store' }), fetch(URL, { next: {revalidate: 0 } }): getServerSideProps와 유사하게 캐싱하지 않고 매번 새로운 데이터를 불러온다.
- fetch(URL, { next: { revalidate: 10 } }): getStaticProps에 revalidate를 추가한 것과 동일하며, 정해진 유효시간 동안에는 캐싱하고, 이 유효시간이 지나면 캐시를 파기한다.
