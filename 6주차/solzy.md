### 📅 2024년 4월 24일

# 📚 10장 리액트 17과 18의 변경 사항 살펴보기

### 10.1.2 이벤트 위임 방식의 변경
- 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM요소에 부착하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다.
- 이를 이벤트 위임이라 한다.

#### 이해가 안가서...

#### 일반적인 이벤트 처리방식
```
<div id="target"></div>
<script>
  const doSomething = () => {
    console.log("doSomething");
  };
  document.querySelector("#target").addEventListener("click", doSomething);
</script>
```
- 해당 dom 요소에 이벤트를 직접 부착함.

#### 리액트에서 이벤트 처리방식
```typescript
return (<button onClick={handleClick}/>
```

- React에서 등록한 이벤트는 해당 요소에 직접 등록되지 않고, 모두 document나 root 요소에 등록
- 따라서, 실제 우리가 요소에 onClick등의 프로퍼티에 명시를 하더라도 실제 등록되는것은 root 요소에 등록됨.
- 리액트 17부터 이러한 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트의 최 상단 트리, 즉 루트요소로 변경됨

즉, 리엑트는 이벤트 핸들러를 각 요소가 아닌 root에 연결해 이벤트를 좀 더 효율적으로 관리함.
- 이렇게 이벤트를 상위에 붙이는 것을 이벤트 위임이라 함.

#### 이런 패턴을 사용하는 이유
 - 메모리 절약.
 - 핸들러를 개별로 부착하는것보다 상위 하나의 요소에만 부착하는것이 메모리를 절약할수 있기 때문.
 - 하지만, React에서는 이벤트를 이미 위임해서 처리하므로 개발자가 이벤트 위임패턴을 사용하지 않아도 됨.

아래 두 예시는 성능적으로 별 차이 없음.

```typescript
// selectedItems = new Set([1, 2, 3])
// ids = [0, 1, 2, ..., 2999]

{ids.map((id) => (
  <FancyButton
    key={id}
    id={id}
    label={id}
    isSelected={selectedItems.has(id)}
    onClick={() => handleClick(id)}
  />
))}
```

```typescript
const handleClick = (event) => {
  // Get id from button element
  const id = event.target.id;
  setSelectedItems((prevState) => new Set([...prevState, id]));
};


<div className="container" onClick={handleClick}>
  {ids.map((id) => (
    <FancyButton
      key={id}
      id={id}
      label={id}
      isSelected={selectedItems.has(id)}
    />
  ))}
</div>
```


### 10.1.3 import React from 'react'
- 더이상 선언해주지 않아도 됨.

### 10.1.4 그 밖의 주요 변경 사항
#### 이벤트 풀링 제거
- SynteticEvent
  - native event객체를 래핑한 객체
  - 이벤트가 발생할때마다 native 객체를 SyntheticEvent객체로 래핑
  -  너무 많은 객체가 필요하므로 성능상 문제 발생
  

  event pool 로 해결
  -  Synthetic Event Instance 들이 들어있는 공간
  -   이벤트가 발생하면 이를 사용한뒤 끝나면 바로 초기화 시키고 다시 풀로 돌려놓는 것
  -  하지만 event pool 은 핸들러 동작이 끝나면 곧바로 이벤트 객체를 초기화 하므로 비동기적인 동작은 실행되지 않음.
  -  e.persist()를 사용해 다른 메모리에 정보를 저장해 두어야 사용할수 있다고 함.


=> react 17버전에서는 제거됨



#### useEffect 클린업 함수의 비동기 실행
클린업 함수가 완전히 비동기적으로 실행
- 컴포넌트의 커밋단계가 완료될 때 까지 지연됨
- 화면이 업데이트가 완전히 끝난 이후에 실행되도록.


## 리액트 18버전 살펴보기

### 새로 추가된 hook
#### useId
- 컴포넌트 별로 유니크한 값을 생성

#### useTransition
- UI변경을 가로막지 않고 상태를 업데이트 할 수 있는 리액트 훅
- 마치 비동기처럼 동작
- 느린 렌더링 과정에서 로딩 화면을 보여주거나 지금 진행중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 됨.

#### useDeferredValue

- 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅


#### 테어링 현상
- 하나의 state값임에도 서로 다른 값을 기준으로 렌더링되는 현상
- 리액트18부터 동시성의 개념이 추가되면서 생긴 문제같음.
- 이 현상을 해결하기 위한 훅이 바로 `useSyncExternalStore`

#### useInsertionEffect
DOM이 실제로 변경되기 전 동기적으로 실행
- 스타일을 삽입하는 코드를 넣음으로써 브라우저가 레이아웃을 계산하기 전에 실행하게끔 더 자연스러운 스타일 삽입이 가능함.

- useLayoutEffect와 차이점은, useLayoutEffect은 모든 DOM의 변경작업이 다 끝난 이후에 실행됨.

### 자동배치
- 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- 리액트18부터 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됨.

### 더욱 엄격해진 엄격모드
엄격모드
- 잠재적인 버그를 찾는데 도움이 되는 기능
- 개발자모드에서만 작동
- 개발자모드에서 렌더링이 두번실행되는 것 처럼 느낄때가 있는데
- 이는, 리액트의 모든 컴포넌트는 순수하다고 가정(함수처럼 동일한 매개변수를 넘기면 늘 같은 값을 리턴한다.) 하기 때문에, 이를 잘 지키고 있는지 항상 순수한 결과물을 내고 있는지 확인시켜주기위해 두번 실행하게 되는 것.


# 📚 11장 Next.js 13과 리액트 18
## 11.1 app 디렉터리의 등장
- next.js 버전 이전까지엔 페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app` 이 유일
- 하지만 이 방법은 제한적이고 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족
- 이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃

- layout.tsx
- page.tsx
- error.tsx
- not-found.tsx
- loading.tsx
모두 예약어로 쓰이며, 각각 역할에 맞는 페이지가 만들어짐.

## 11.2 리액트 서버 컴포넌트
- 서버사이드 렌더링과는 완전히 다른 개념

### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계
- 리액트의 모든 컴포넌트는 클라이언트에서 작동
- 브라우저에서 자바스크립트 코드 처리가 이루어짐
- 서버 사이드 렌더링의 경우, 서버에서 미리 DOM을 만들고, 클라이언트에서는 만들어진 DOM을 기준으로 하이드레이션을 진행

#### 이러한 구조의 한계점

1. 무거운 라이브러리를 클라이언트에서 다운로드도 하고 실행도 해야한다는 점.
- 서버에서 라이브러리를 실행한 결과를 클라이언트에 리턴만 해준다면, 클라이언트에서 무거운 라이브러리를 다운로드/실행해야 하는 부담은 사라지지 않을까?

2. 백엔드 리소스에 대한 직접적인 접근이 불가능
- 프론트엔드 코드내에서 직접 백엔드에 접근해 원하는 데이터를 가져올 수 있다면 좋지 않을까?

3. 자동코드분할이 불가능
- 코드분할이란 하나의 거대한 코드 번들 대신, 코드를 여러 작은 단위로 나누어 필요할 때만 동적으로 지연 로딩함으로서 앱을 초기화하는 속도를 높여주는 기법
- 이미 리액트내에서도 lazy기법이 있지만 일일이 감싸야함.

4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어려움

- 서버사이드 렌더링은 정적 콘텐츠를 빠르게 제공하고 서버에 있는 데이터에 손쉽게 제공할 수 있는 반면, 사용자의 인터랙션에 따른 다양한 사용자 경험을 제공하긴 어려움.

### 11.2.2 서버컴포넌트
- 서버와 클라이언트 모두에서 컴포넌트를 렌더링 할 수 있는 기법
- 일부 컴포넌트는 클라이언트가, 일부는 서버에서 렌더링되는 것
- 명심해야 하는 건, 클라이언트 컴포넌트는 서버 컴포넌트를 import할 수 없음.

#### 서버컴포넌트
- 서버에서 한 번 실행될 뿐이므로 상태를 가질 수 없음.
- 렌더링 생명주기도 사용할 수 없음.
- 브라우저 API사용 불가능.

- 리액트는 어떻게 서버컴포넌트와 클라이언트 컴포넌트를 구분할까
  - 모든 컴포넌트를 다 서버에 실행가능하다고 판단.
  - 다만, 클라이언트 컴포넌트라는 것을 명시적으로 선언이 필요. `use client`

### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이
- **서버사이드 렌더링**은 **응답받은 페이지 전체를 HTML로 렌더링 하는 과정을 서버에서 수행** -> 그 결과를 클라이언트에 내려줌
- 그리고, 클라이언트는 하이드레이션 과정을 거쳐 이벤트와 스타일을 붙여줌.
- 정적 HTML을 빠르게 내려주는 데 초점을 두고 있음.
- 그러므로 클라이언트에서 자바스크립트 코드를 다운로드하고 파싱하고 실행하는데 드는 비용은 여전히 듦.

- 서버 컴포넌트를 활용해 초기 HTML을 빠르게 전달하고, 클라이언트 컴포넌트는 서버사이드렌더링 으로 빠르게 HTML을 전달받을 수 있다.
- 즉 서버사이드렌더링과 서버컴포넌트의 두가지 방법을 통해 브라우저의 부담을 더는 것.
- **대체제가 아닌 상호보완의 개념으로 봐야함!**

### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?

1. 서버가 렌더링을 요청받음.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화
  - 서버에스 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분을 해당 공간을 비워둠.
  - 브라우저는 이 후에 이 결과물을 받아 역직렬화한 다음 렌더링 수행
3. 브라우저가 리액트 컴포넌트 트리를 구성
  - JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성

- 즉, 서버에서 클라이언트로 정보를 보낼 때 스트리밍 형태로 보냄.
- 컴포넌트들이 각 컴포넌트별로 번들링이 별개로 되어있어 필요에 따라 컴포넌트를 지연해서 받거나 따로 받는 등 작업이 가능.
- JSON형태로 보내진다는 것. => 리액트 컴포넌트 트리의 구성을 최대한 빠르게 할 수 있도록 도와줌.
      - 이러한 특징으로 인해 서버컴포넌트에서 클라이언트 컴포넌트로 props를 넘길 때 반드시 직렬화 가능한 데이터를 넘겨야 함.(class, Date 불가능)

### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기
**과거 서버사이드 렌더링 방식의 단점**
- 서버에서 DOM을 렌더링하고 클라이언트에서 하이드레이션 과정으로 이벤트와 스타일이 연결될 때 까지 사용자는 페이지를 사용할 수 없게 됨.

-> 사용자가 일부라도 페이지와 인터렉션을 할 수 있는 기법 : 스트리밍

## 11.4 웹팩의 대항마, 터보팩의 등장
- 차세대 모듈 번들러
- 개발모드에서만 쓸 수 있음........

#### swc 는 뭔데,,,
- 자바스크립트 코드를 트랜스파일하거나 타임스크립트 코드를 컴파일하는 개발 도구..


