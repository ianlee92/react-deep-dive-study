### 📅 2024년 4월 24일

# 📚 10장 리액트 17과 18의 변경 사항 살펴보기

## React17

- 점진적 업그레이드 가능해짐
- 이벤트 위임 방식 변경
  - 이벤트 위임
  - 캡처: 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타깃요소까지 내려가는 것.
  - 타깃: 이벤트 핸들러가 타깃 노드에 도달하는 단계.
  - 버블링: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다. 
- 16버전까지는 document.
- 17버전부터는 리액트 컴포넌트 최상단 트리. = 루트요소로 변경됨.
- jsx transform.
- 이벤트 풀링 제거
- useEffect 클린업 함수의 비동기 실행

## React18

- 새로 추가된 훅
    - useId
        - 컴포넌트별로 유니크한 값을 생성해준다.
    - useTrasition
        - UI의 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
        - **동시성 렌더링이 가능함**
        - 무거운 렌더링 작업이 필요한 경우 사용하면 사용자의 편의성을 높일 수 있음.
    - useDeferredValue
        - 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅.
        - useTransition은 state값을 업데이트하는 함수를 감싸서 사용
        - useDefferedValue는 state 값 자체만을 감싸서 사용.
    - useSyncExternalStore
        - 테어링 tearing 현상을 방지하기위한 훅.
        - 리액트 외부에서 가져오는 데이터 소스를 사용할 때 동시성 이슈를 해소할 수 있는 훅
    - useInsertionEffect
        - DOM 변경 작업 이전에 실행되어 해당 작업으로 인해 DOM이 다시 계산되어야하는 경우, DOM을 재계산하지 않아도 되는 장점이 있음.
        - useInsertionEffect → useLayoutEffect → useEffect
- createDOM
- hydrateRoot
    - 서버사이드렌더링 어플리케이션에서 하이드레이션을 위한 새로운 메소드
- onRecoverableError: 리액트 렌더링 또는 하이드레이션 과정에서 에러가 발생했을 때 실행하는 콜백함수
- 자동 배치
    - 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- 엄격모드 강화
    - 사이드이펙트 검사
        - 컴포넌트를 두 번씩 실행 ← 함수형 프로그래밍 원칙에 따라 리액트의 모든 컴포넌트는 항상 순수하다고 가정한다.
- Suspense 기능 강화
- null 반환과 undefined 반환이 동일하게 처리된다.


# 📚 11장 Next.js 13과 리액트 18

## Next13

- app 디렉터리
    - layout: 해당 파일 하위에 위치하는 모든 페이지에 영향을 미치는 공통 레이아웃.
        - app 디렉터리 내부에서 사용되는 예약어이므로, 다른 용도로 사용될 수 없다.
        - children을 prop으로 받아 렌더링해야한다.
    - page.js
        - 기존 Nextjs의 페이지를 의미한다.
        - params - 동적 라우트 파라미터
        - searchParams
    - error.js
        - 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트
    - not-found.js
    - loaidng.js
        - 리액트 Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.
    - route.js
        - API 메서드를 지원.
        - request: API 요청 객체. fetch의 request를 확장한 Request 객체.
        - context: params만을 가지고있는 객체.
- 리액트 서버 컴포넌트
    - 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법.
    - 서버 컴포넌트와 클라이언트 컴포넌트가 혼재될 수 있다.
    - 요청이 오면 그 순간에 딱 한 번 실행됨. 상태를 가질 수 없다.
    - 브라우저에만 존재하는 window, document 등을 사용할 수 없다.
    - 서버 데이터를 async/await으로 접근할 수 있다. 컴포넌트 자체 async가 가능함.
    - 다른 클라이언트 컴포넌트를 렌더링할 수 있다.
- 클라이언트 컴포넌트
    - 서버컴포넌트 불러오기 불가.
    - `서 > 클 > 서` 는 가능.
- 리액트는 모든 것을 다 공용 컴포넌트로 판단한다. 즉, 모든 컴포넌트를 서버에서 실행 가능한 컴포넌트로 판단한다.
- 클라이언트 컴포넌트라는 것을 명시적으로 지정해야만 클라이언트컴포넌트로 인식한다. “use client”

### 서버사이드 렌더링 vs 서버 컴포넌트

- 서버사이드 렌더링
    - 응답받은 페이지 전체를 html로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려준다.
    - 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물 확인 및 이벤트를 붙인다.
    - 초기 인터렉션은 불가하지만 정적인 html을 빠르게 내려주는 데 목적을 두고있다.
- 서버 컴포넌트
    - 서버에서 컴포넌트 렌더링을 완성하여 제공한다.
1. 서버컴포넌트를 사용하는 페이지는 항상 서버에서 시작된다. 루트에 있는 컴포넌트는 항상 서버 컴포넌트.
2. 서버는 받은 요청을 json으로 직렬화한다.
    1. 서버에서 렌더링할 수 있는 부분은 직렬화해서 내보낸다.
    2. 클라이언트 컴포넌트 부분은 플레이스홀더 형식으로 비워두고 나타낸다.
    3. 브라우저는 이 결과물을 받아서 역직렬화한 다음 렌더링을 수행한다.
- fetch가 getServerSideProps 등의 서버사이드 렌더링을 위한 메서드를 대체할 수 있다.

- 터보팩
    - 러스트 기반으로 작성되어 웹팩 대비 높은 성능을 가진다.
- 서버 액션
    - “use server” 지시자를 선언해야 한다.
    - 특정 함수 실행 그 자체만을 서버에서 실행할 수 있다.
    - form의 action
- 로딩, 스트리밍, 서스펜스