### 📅 2024년 3월 20일

# 📚 3장 리액트 훅 깊게 살펴보기
**hook**
- 함수형 컴포넌트에서 상태(state) 를 사용하거나 클래스형 컴포넌트의 생명주기 메서드를 대체하는 등 다양한 작업을 실행.

## 3.1 리액트의 모든 훅 파헤치기
### 3.1.1 useState
> 함수형 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅


```typescript jsx
const [state, setState] = useState(initialState)
```

- 초깃값을 넘겨주지 않으면, 초깃값은 `undefined`
  

- 리액트의 렌더링은 **함수형 컴포넌트에서 반환된 결과물인 return 의 값을 비교해 실행**
- 매번 렌더링이 발생할 때 마다 함수를 다시 새롭게 실행되며, 새롭게 실행되는 함수에서는 로컬변수들은 매번 초기화
- 그럼에도, state가 렌더링이 일어나도 매번 이전 값을 유지할 수 있었던 이유는, **클로저를 이용해 구현**되어 있기 때문

#### 게으른 초기화
```typescript jsx
const [count, setCount] = useState(() => {
  // 무거운 연산
  return ..
})
```
> useState의 초깃값으로 함수를 대신 넘기는 것.

- useState 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
- 오로지 state가 처음 만들어질 때만 사용
- 최초 상태 선언시 성능개선을 위한 방법 !

### 3.1.2 useEffect
> - 어플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘.
> - 렌더링 과정에서 실행되는 부수효과 함수

중요한건, 이 부수 효과가 `언제` 일어나는지보다 `어떤 상태값과 함께 실행되는지 살펴보는 것`이 중요 !

#### useEffect 란?

```typescript jsx
function Component() {
  useEffect(() => {
    // do something
  }, [props, state])
  
}
```
- 의존성 배열이 변경될 때 마다 useEffect의 첫번째 인수인 콜백 함수를 실행

`useEffect` 는 의존성 배열이 변경된 것을 어떻게 알까?
- 함수형 컴포넌트는 매번 함수를 실행에 렌더링을 수행
- 렌더링할 때 마다 의존성에 있는 값들을 보면서, 이 의존성의 값이 이전과 다른게 하나라도 있으면 콜백함수를 실행하는 것

#### 클린업 함수의 목적
- 일반적으로 이벤트를 등록하고 지울 때 사용해야 한다고 알려져 있다.
```typescript jsx
useEffect(() => {
  return () => {
    // clean up logic..
  }
})
```

- 클린업 함수는 이전 state를 참조해 실행된다.
- 클린업 함수는 렌더링 뒤에 실행되지만, 변경된 값을 읽는게 아닌, 함수가 정의되었을 당시에 선언되었던 이전 값을 보고 실행된다.

#### useEffect에 이벤트를 추가했을 때 클린업 함수에서 지워야 하는 이유
- `useEffect` 는 콜백이 실행될 때 마다, 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.
- 이벤트를 추가하기 전에, 이전에 등록했던 이벤트를 지워주는 것이다.
- 지워주지 않으면, 콜백함수가 매번 실행될 때 마다 이벤트 핸들러가 무한히 추가된다.

#### 클린업 함수는 컴포넌트가 언마운트 될 때 실행되는 것이 아니다
- `언마운트` : 특정 컴포넌트가 DOM 에서 사라질 때
- `클린업 함수` : 함수형 컴포넌트가 리렌더링 되었을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는 함수

> https://choyeon-dev.tistory.com/10

#### 의존성 배열

```
// 1. 직접실행
function ComponenetA() {
  console.log("render");
}

// 2. 
function ComponentB(){
  useEffect(() => {
  console.log('render');
  })
}
```

1. 직접 실행은 **컴포넌트가 렌더링 되는 도중**에 실행됨. **서버사이드 렌더링의 경우에서도 실행**된다는 것.
2. - `useEffect` 는 **클라이언트 사이드**에서 실행되는 것을 보장함. `useEffect` 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 됨.
    -  `useEffect` 는 컴포넌트 렌더링이 완료된 뒤에 실행됨.


#### useEffect를 사용할 때 주의해야 할 점
1. `eslint-disable-line react-hooks/exhaustive-deps` 주석은 자제하자
- useEffect 는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행되어야 하는 훅
- 컴포넌트의 state, props와 같은 어떤 값의 변경과 별개로 작동하게 됨

2. useEffect에 첫번째 인수에 함수명을 부여하라
```typescript jsx
// callback 함수가 익명 함수가 아닌 기명 함수
useEffect(
	function logActiveUser() {
    	logging(log);
    },
    [user.id],
)
```

- useEffect 가 복잡해질 수록 무슨일을 하는 부수효과인지 파악하기 어려워짐.
- 이름을 붙여 무슨 목적의 코드인지 파악할 수 있도록 하자.

3. 거대한 useEffect 를 만들지 마라
- 부수효과가 커질수록 애플리케이션 성능에 악영향을 미친다.
- 가능한 간결하고 가볍게 유지.


4. 불필요한 외부 함수를 만들지 마라
- useEffect 내에서 사용할 함수들이라면 useEffect 내부에서 정의해서 사용하자

### 3.1.3 useMemo
> 비용이 큰 연산에 대한 결과를 메모이제이션 해두고, 이 저장된 값을 반환하는 훅
- 단순히 값뿐만 아니라 컴포넌트도 메모이제이션이 가능하다.
- `useMemo`로 감쌀 수 있으며, `React.memo` 도 가능하다.

### 3.1.4 useCallback
> 인수로 넘겨받은 콜백 자체를 기억한다. 즉, 특정 함수를 새로 만들지 않고 다시 재사용 한다는 의미.
- 함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 `useCallback` 을 사용해볼 수 있다.

**`useMemo` 와 `useCallback` 의 유일한 차이**
- 메모이제이션을 하는 대상이 변수냐 함수냐

### 3.1.5 useRef
> state와 동일하게 컴포넌트 내부에서 렌더링이 일어나도 변경 가능한 상태값을 저장한다.
- 반환값인 객체 내부 current 로 값에 접근 / 변경이 가능하다.
- 값이 변하더라도 렌더링을 발생시키지 않는다.

#### 컴포넌트 외부에 상수를 선언해서 관리하면 안되나 ?

```typescript jsx
let value = 0
function Component() {
  ...
}
```

- 컴포넌트를 실행되어 렌더링되지 않아도, value라는 값은 존재한다. 이는 메모리에 불필요한 값을 갖게 하는 악영향
- Component 가 여러번 생성되면 각 컴포넌트에서 가리키는 값이 모두 value로 동일

> useRef는 이러한 단점을 극복함.
> - 컴포넌트가 렌더링 될 때만 생성되며,
> - 컴포넌트 인스턴스가 여러개라도 각각 별개 값을 바라본다.

- 값이 변경되어도 렌더링이 안되는 이유는, 실체값은 객체로 되어있고, 내부 프로퍼티 current 변경할 뿐 객체 참조는 동일하기 때문이다.

### 3.1.6 useContext
#### Context
- 과도한 props drilling 을 피하기 위한 개념

#### useContext 를 사용할 때 주의할 점
- 컴포넌트 재활용이 어렵다.
- useContext 가 선언되어 있으면, Provider 에 의존성을 가지고 있는 셈이므로, 아무데서나 재활용하기는 어렵다.
 useContext는 상태관리 API가 아닌, 상태를 주입해주는 API
- provider에서 내려주는 value가 변하면 모든 하위 컴포넌트들이 리렌더링이 일어난다.

### 3.1.7 useReducer
> 복잡한 형태의 state를 사전에 정의된 dispatcher 로만 수정할 수 있게 만들어줌
- state를 사용하는 로직과 이를 관리하는 비즈니스 로직을 분리할 수 있어 state를 관리하기가 쉬워진다.

### 3.1.7 useImperativeHandle
> 부모에게서 넘겨받은 ref를 원하는대로 수정할 수 있는 hook

```typescript jsx
// [전]
const CommonComponent: ForwardRef<T,P> = ({...}, ref => {
  
  return <></>
})


const Sample = () => {
  const ref = useRef()
  
  useEffect(() => {
    if (ref) {
      ref.current.foo = () => {
      // 공통로직
      }
    }
  }, [ref])
  
  return <CommonComponent ref={ref}/>
}

// [후]

const CommonComponent: ForwardRef<T,P> = ({...}, ref => {

  useImperativeHandle(
    ref,
    () => {
      return {
        foo() {
          minRef?.current?.focusIn()
        },
      }
    },
    [],
  )
  
  return <></>
})

```

### 3.1.8 useLayoutEffect
> useEffect와 동일하나, 모든 DOM의 변경후에 동기적으로 발생한다.
1. 리액트가 DOM을 업데이트
2. useLayoutEffect를 실행
3. 브라우저에 변경사항 반영
4. useEffect를 실행

- 동기적으로 발생한다는 것은, 리액트는 useLayoutEffect 의 실행이 종료될 때 까지 기다린 다음에 화면을 그린다.

#### 언제 사용하나요?
- DOM은 계산되었지만 이것이 화면에 반영되기 전에 하고싶은 작업이 있을 때 같이 사용

### 3.1.10 useDebugValue
> 디버깅 하고 싶은 정보를 훅에다 사용하여 개발자 도구에서 볼 수 있게 해주는 hook
> https://rainsister.tistory.com/139

### 3.1.11 훅의 규칙
- 최상위에서만 호출
- 자바스크립트 함수에서는 쓸 수 없다.

## 3.2 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
### 3.2.2 고차 컴포넌트
- ex: `React.memo`
- 공통되는 로직을 고차 컴포넌트에 위임
- 컴포넌트 전체를 감쌀 수 있다는 점에서 더 큰 영향력을 컴포넌트에 미칠 수 있음.
- 컴포넌트의 결과물에 영향을 미칠 수 있는 다른 공통된 작업을 처리할 수 있다.
- `~with` 라는 접두사로 된 컴포넌트를 만들어야 함.

### 3.2.3 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
- 사용자 정의 훅 : 공통 로직 격리
- 고차 컴포넌트를 사용해야하는 경우: 함수형 컴포넌트의 반환값, 즉 렌더링의 결과물에도 영향을 미치는 공통로직 

# 📚 5장 리액트와 상태 관리 라이브러리
## 5.1 상태 관리는 왜 필요한가?
> 상태란 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.
- UI
- URL
- form
- 서버에서 가져온 값

### 5.1.1 리액트 상태 관리의 역사
#### Flux
- action -> dispatcher -> model -> view
- 단방향으로 데이터 흐름을 변경하는 패턴
- store에 action과 상태값을 선언하고, dispatcher로 액션을 실행해 view에 보여주는 패턴

#### Redux
- Flux구조를 구현하기 위해 만들어진 라이브러리 중 하나.
- 하나의 상태 객체를 스토어에 저장해두고, 이 객체를 업데이트 하는 작업을 디스패치해 업데이트를 수행

#### Context API 와 useContext
- props 로 상태를 넘겨주지 않아도 Context API를 사용하면 원하는 곳에서 Context Provider 가 주입하는 상태를 사용할 수 있게 된 것.
- 상태관리가 아닌 주입을 도와주는 기능
- 상태가 변할 때 마다 하위 컴포넌트들이 렌더링이 일어나는 단점

#### Hook의 탄생, 그리고 React Query 와 SWR

#### Recoil, Zustand, Jotai, Valiio에 이르기까지

### 5.2 리액트 훅으로 시작하는 상태관리

#### 4.2.1 가장 기본적인 방법: useState와 useReducer
- 리액트 훅을 기반으로 만든 사용자 정의 훅은 함수형 컴포넌트라면 어디에서든 손십게 재사용 가능하다는 단점
- 사용자지정 훅의 한계는 훅을 사용할 때 마다 컴포넌트 별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다.
- 지역상태라고도 한다.

#### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기
- 꼭 window, global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 함
- 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고, 상태가 변할 때 마다 리렌더링이 일어나야 한다.
- 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다.


#### 5.2.4
#### Recoil

- `<RecoilRoot/>`
  - 상태가 변할 때 이 변경된 상태를 하위 컴포넌트로 전파해 컴포넌트에 리렌더링을 일으키는 `notifyComponents` 가 존재

#### Jotai
- Recoil과 다르게 atom 하나만으로도 상태를 만들수도, 또 이에 파생된 상태를 만들 수 있다.
