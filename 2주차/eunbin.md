### 📅 2024년 3월 20일

# 📚 3장 리액트 훅 깊게 살펴보기

- 렌더링은 어떻게 일어날까?
  - return문을 실행한 다음, 이 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트한다.

### useState

클로저를 사용함으로써 외부에 해당 값을 노출시키지 않고 오직 리액트에서만 쓸 수 있었고, 함수형 컴포넌트가 매번 실행되더라도 useState에서 이전의 값을 정확하게 꺼내 쑬 수 있게 되었다.

#### 게으른 초기화

게으른 초기화는 useState의 초기값을 할당할 때 값을 반환하는 함수를 정의하는 방법이다.

useState의 초기값으로 사용된 함수는 최초 렌더링시에만 호출되고 이후의 리렌더링 시점에서는 무시된다. 따라서 자바스크립트에 많은 비용을 요구하는 작업이 들어가 있는 경우에 사용하는 것이 좋다.

```jsx
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

ex) localStorage나 SessionStorage에 접근, map, filter, find와 같은 배열에 대한 접근, 또는 초기값 계산을 위해 함수 효출이 필요한 경우 등

### useEffect

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수효과를 만드는 메커니즘.
- state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수효과 함수.
- 어떤 상태값과 함께 실행되는가?

- 클린업 함수가 실행되는 타이밍

  - useEffect의 콜백이 실행될 때 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤에 콜백을 실행한다.
  - 이때 실행되는 클린업 함수는 **이전 렌더링 시의 state와 함께 실행**된다.
  - 언마운트와는 조금 다름. 언마운트는 특정 컴포넌트가 DOM에서 사라지는 시점을 의미.

- 의존성 배열
  - 빈 배열: 최초 렌더링 직후에 실행된 이후 실행되지 않음.
  - 아무 값도x: 렝더링이 발생할 때마다 실행.
  - Object.is를 기반으로 하는 얕은 비교를 수행한다.

부수효과가 뭐지? 함수형 컴포넌트에서 외부 값을 변화시키는 행위, 데이터 페칭

- hook이 실행 순서를 보장받을 수 있는 최상단에 선언되어있어야 하는 이유
  - 리액트 훅은 파이버 객체의 링크드 리스트의 호출 순서 따라 저장되고, 이 고정된 순서를 기준으로 이전 값과의 비교 및 실행이 가능하다.

### useMemo

- 비용이 큰 연산을 저장해두고, 이 저장된 값을 반환.
- 컴포넌트도 메모이제이션 가능

### useCallback

- 콜백으로 넘겨받은 함수 자체를 기억
- 특정 함수를 새로 만들지 않고 재사용한다.

### useRef

- useState와 동일하게 렌더링이 일어나도 변경 가능한 상태값을 저장
- useState와 다르게 변경 시 렌더링되지 않는다.

### useContext

- Context: props drilling을 극복하기 위해 도입된 개념. 단순하게 하위 컴포넌트들에게 상태를 주입해줌
- 주의할 점
  - 컴포넌트의 재사용이 어려워진다. 해당 Provider와의 의존성을 갖게됨.
  - 상태가 변경될 때마다 Provider 하위 컴포넌트들에 리렌더링이 일어난다. 렌더링 최적화가 일어나지 않음

### useReducer

- useState와 비슷하지만 좀 더 복잡한 상태를 관리하는 데 유리하다.
- 컴포넌트 안에서만 값에 접근가능, state는 dispatcher함수로만 업데이트 가능하도록. state를 변경하는 시나리오를 제한적으로 둠으로써 변경을 빠르게 확인할 수 있게 됨.

### useImperativeHandle

- ref를 하위 컴포넌트에 전달한 경우에 하위컴포넌트가 ref를 원하는대로 수정할 수 있는 훅.
- 하위 컴포넌트가 재사용되고있고, ref를 통해 추가적인 작업이 필요한 경우 사용할 수 있을 것 같다.

### useLayoutEffect

- 브라우저에 변경사항이 반영되기 전에 실행.
- 동기적으로 동작하므로 어플리케이션 성능 문제가 발생할 가능성이 있다.
- DOM은 계산됐지만 이것이 화면에 반영되기 전에 하고싶은 작업이 있을때

### 훅을 실행 순서를 보장받을 수 있는 최상위에서만 호출해야하는 이유

- 리액트 훅은 파이버 객체의 링크드리스트 호출 순서에 따라 저장되는데, 이때 각 순서에 맞는 state나 effect의 결과에 대한 값을 저장하고있음. 이 고정된 순서를 기반으로 이전 값에 대한 비교와 실행이 가능함.

### 사용자 정의 훅과 고차 컴포넌트

- 사용자 정의 훅
  - 복잡하고 반복되는 로직을 분리할 수 있다.
  - 렌더링에는 영향을 미칠 수 없다.
  - 단순히 컴포넌트 전반에 걸쳐 동일한 로직으로 값을 제공하거나 특정한 훅의 작동을 정의하고싶은 경우 사용한다.
- 고차 컴포넌트
  - 컴포넌트 자체의 로직을 재사용하기 위한 방법
  - React.memo: props가 바뀌지 않는 한 하위 컴포넌트가 리렌더링되지 않도록 막는다.
  - `with~`와 같은 이름으로 선언해야한다.
  - 사용자 정의 훅에 비해 동작을 예측하기 어렵다. 렌더링에 직접적으로 영향을 미치기도한다.
  - 렌더링 로직을 공통화하기 좋은 방법!

# 📚 5장 리액트와 상태 관리 라이브러리

- 상태의 종류: UI, URL, 폼, 서버에서 가져온 값
- flux 패턴.
  - 양방향 바인딩: 뷰가 모델을 변경할 수 있고, 모델도 뷰를 변경할 수 있다.
  - 단방향 바인딩: 뷰는 모델을 변경할 수 없다. 데이터의 흐름을 예측하기 쉽다. 하지만 코드의 양이 늘어난다.
- react query, SWR
  - fetch를 관리하기 좋은 라이브러리. 특히 HTTP 요청에 특화된 상태 관리 라이브러리.
  - 키값으로 받은 값을 사용해서 캐싱을 적용해준다.

## 상태관리 방법

### useState와 useReducer 활용하기

- 두 hooke 모두 지역 상태를 관리하기위해 만들어졌다.
- 한계: 지역 상태이기 때문에 해당 컴포넌트 내에서만 유효하다. 훅을 사용할 때마다 컴포넌트별로 초기화되어 컴포넌트마다 다른 상태를 가질 수밖에 없다.
- 여러 컴포넌트에 걸쳐 동일한 state를 공유하도록 하기 위해서는 컴포넌트 트리를 재설계해야한다.

### useState와 useContext 동시에 사용하기

- useState와 useReducer가 가지고있는 지역 상태의 한계를 극복할 수 있다.
- 컴포넌트 최상단 또는 격리된 자바스크립트 코드어딘가에 상태를 두고 이 상태 변경을 감지하여 리렌더링을 발생시킨다.

### 상태관리 라이브러리들

- Recoil
  - 메타에서 개발.
  - 최소 상태 개념 : Atom
  - Recoil Root를 컴포넌트 최상단에 둔다. -> Recoil에서 생성되는 상태값을 저장하기 위한 스토어를 생성한다.
  - useRecoilValue: atom의 값을 읽어온다.
  - useRecoilState: useState와 유사. 값을 가져오고 변경도 가능하다.
- Jotai
  - Recoil의 atom 모델에서 영감을 받아 만들어짐.
  - 상향식 접근법을 취하고있다.
  - 렌더링 최적화 기능이 제공된다.
- Zustand
  - 리덕스에 영감을 받음.
  - 하나의 스토어를 중앙집중형으로 활용. 이 스토어 내부에서 상태를 관리한다.
  - state값을 useState 외부에서 관리한다.
  - 리덕스에 비해 빠르게 스토어를 만들고 사용할 수 있다.
  - 라이브러리의 크기가 작다!
  - 여러 미들웨어를 제공한다.
