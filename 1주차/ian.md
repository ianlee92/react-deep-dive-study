### 📅 2024년 3월 13일

# 📚 들어가며

### p.3, 11

- 당시 대부분의 프레임워크는 **양방향 바인딩** 구조를 채택해 모델과 뷰가 밀접한 관계를 맺고 서로가 서로를 변경할 수 있는 구조였다.
- 이러한 방식은 코드를 작성하는 것은 간단하지만 변경된 DOM을 추적하는 것이 어렵고, 왜 이렇게 변경됐는지 역시 추적하기 어려워 수많은 버그가 발생하던 지점이기도 했다.
- **리액트는 단방향 바인딩**만 지원한다. 말 그대로 데이터의 흐름이 한쪽으로만 간다는 것이다.
- 모델이 뷰를 변경하는 단방향 방식은 모델의 데이터가 변경되어 뷰가 변경되어야 하면 이전 DOM을 버리고 새롭게 렌더링하는 방식을 제안했다.

### p.16

- 전통적인 MVC 패턴을 유지해 개발하는 것에 어려움을 느꼈으며, 예측 가능한 데이터 흐름, 독립적인 컴포넌트 개발 등을 목표로 리액트와 Flux 패턴을 도입했다.

### p.18

- Angular나 Vue 같은 다른 라이브러리와는 다르게, 웹 개발을 위한 프레임워크를 지향하지 않으므로 리액트와 함께 사용할 수 있는 다양한 라이브러리가 있다.

# 📚 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

### p.41

- 화살표 함수에서의 this는 우리가 원하는 대로 클래스의 인스턴스인 this를 가리키는 것을 볼 수 있다.
- 즉, 별도의 작업을 추가하지 않고 this에 접근할 수 있는 방법이 바로 화살표 함수인 것이다.

### p.39, 43, 44

- **_즉시 실행 함수_**(Immediately invoked Function Expression, 일반적으로 IIFE라고 부른다)는 말 그대로 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다. 단 한 번만 호출되고, 다시금 호출할 수 없는 함수다. 그래서 일반적으로 즉시 실행 함수에 이름을 붙이지 않는다.

  ```tsx
  (function (a,b) {
    return a + b
  })(10, 24); // 34

  ((a, b) => {
    return a + b
  },
  )(10, 24) // 34
  ```

- **_일급 객체_**란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. 자바스크립트에서 함수는 일급 객체다. 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

  ```tsx
  const sum = function (a, b) {
    return a + b;
  };

  sum(10, 24); // 34
  ```

- **_고차 함수(Higher Order Function)_**은 자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있는데 이런 역할을 한다.

  ```tsx
  const doubeldArray = [1, 2, 3].map((item) => item * 2);

  doubledArray; // [2, 4, 6]
  ```

### p.44

- 함수의 부수 효과(side-effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다. 이러한 부수 효과가 없는 함수를 **_순수 함수_**라 한다.

### p.45

- 부수 효과를 처리하는 훅인 useEffect의 작동을 최소화하는 것이 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설계하는 방법이다. useEffect의 사용은 피할 수 없지만 최소한으로 줄임으로써 함수의 역할을 좁히고, 버그를 줄이며 컴포넌트의 안정성을 높일 수 있다.

### p.59

- 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있기 때문에 함수 컴포넌트 작성을 위해서는 클로저에 대해 이해하는 것이 필수다.

### p.61

- 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉, {} 블록이 스코프를 범위를 결정하지 않는다. {} 내부에 선언되어 있는데도 {} 밖에서도 접근이 가능하다.

  ```tsx
  if (true) {
    var global = "global scope";
  }

  console.log(global); // 'global scope'
  ```

### p.65

- 클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 바로 useState다.

  ```tsx
  function Component() {
    const [state, setState] = useState();

    function handleClick() {
      // useState 호출은 위에서 끝났지만,
      // setState는 계속 내부의 최신값(prev)을 알고 있다.
      // 이는 클로저를 활용하기 때문에 가능하다.
      setState((prev) => prev + 1);
    }
    // ...
  }
  ```

### p.67

- 클로저를 사용할 때 한 가지 주의할 점은, 클로저를 사용하는 데는 비용이 든다는 것이다. 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생한다.

### p.70

- 자바스크립트는 싱글 스레드 언어이다. 자바스크립트의 모든 코드는 동기식으로 한 번에 하나씩 순차적으로 처리된다. 하나의 프로그램에는 하나의 프로세스만이 할당되므로 이러한 작업을 수행하기 어려웠는데, 그래서 탄생한 더 작은 실행 단위가 바로 스레드(thread)다.

### p.72

- 이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치라 볼 수 있다.
- 호출 스택(call stack)은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.

### p.74

- 호출 스택이 비어 있는지 여부를 확인하는 것이 바로 이벤트 루프다. 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 있는지 확인하고, 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.
- 코드를 실행하는 것과 호출 스택이 비어있는지 확인하는 것 모두가 단일 스레드에서 일어난다는 점이다. 즉, 두 작업은 동시에 일어날 수 없으면 한 스레드에서 순차적으로 일어난다.

### p.75

- 태스트 큐란 실행해야 할 태스크의 집합을 의미한다. 이벤트 루프느 이러한 태스크 큐를 한 개 이상 가지고 있다. 그리고 이름과는 다르게 태스크 큐는 자료 구조의 큐(queue)가 아니고 set 형태를 띠고 있다.
- 자료구조인 큐는 무조건 앞에 있는 것을 FIFO(First In First Out) 형식으로 꺼내와야 하지만 태스크 큐는 그렇지 않다.
- 태스크 큐에서 의미하는 실행해야 할 태스크라는 것은 비동기 함수의 콜백 함수나 이벤트 핸들러 등을 의미한다.
- 즉, 이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다.
- 호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 실행 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다. 이 작업 또한 마찬가지로 태스크 큐가 빌 때까지 이루어진다.

### p.76

- 태스크 큐와 다르게, 마이크로 태스크 큐라는 것도 있다.
- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 기존의 태스크 큐와는 다른 태스크를 처리한다.
- 여기에 들어가는 마이크로 태스크에는 대표적으로 Promise가 있다.
- 이 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 즉, setTimeout과 setInterval은 Promise보다 늦게 실행된다.

### p.79

- 브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어난다는 것을 알 수 있다.
- 결론적으로 동기 코드는 물론이고 마이크로 태스크 또한 마찬가지로 렌더링에 영향을 미칠 수 있다.
- 따라서 만약 특정 렌더링이 자바스크립트 내 무거운 작업과 연관이 있다면 이를 어떤 식으로 분리해서 사용자에게 좋은 애플리케이션 경험을 제공해 줄지 고민해 보아야 한다.

### p.95

- forEach는 아무런 반환값이 없다. 단순히 콜백 함수를 실행할 뿐 맵과 같이 결과를 반환하는 작업은 수행하지 않는다.
- 즉, 콜백 함수 내부에서 아무리 반환해도 모두 의미 없는 값이 된다.
- forEach의 반환값은 undefined로 의미 없다는 것을 알아두어야 한다.

# 📚 2장 리액트 핵심 요소 깊게 살펴보기
