### 📅 2024년 3월 13일

# 📚 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등비교

### 1.1.1 자바스크립트의 데이터 타입

- **원시타입**: 객체타입을 제외한 데이터 타입
- **객체타입**: Object

### null
```typescript
typeof null === 'object' 
```
- null은 원시타입이지만 `typeof` 연산자로 타입을 확인해보면 객체타입인 **object**가 나옴.
  - 자바스크립트의 초기버전 버그 
- 그래서, null 타입을 검사하려면, **비교연산자**로 검사해야 함.

**null vs undefined**
- undefined: 선언되었지만 할당되지 않은 값
- null: 명시적으로 비어있음을 나타낸 값

🌱
> **우아한 타입 스크립트 67p**
> - **undefined**
>   - 정의되지 않음을 의미
>   - 초기화 되지 않은 값을 의미
>   - **값이 아직 할당되지 않음** : 변수 선언만 하고 값을 할당하지 않았을 때의 변수의 상태
>
> - **null**
>   - 명시적 or 의도적으로 값이 없음을 보여줄 때
> ----
> - 특정 field가 optional을 나타낼 때 undefined를 주로 사용
> - 특정 데이터가 비어있을 수 있음을 나타낼 때 null를 주로 사용


```typescript
typeof undefined === 'undefined'
```
- undefined 를 `typeof` 로 검사하면 **undefined** 가 나옴.

### 1.1.4 리액트에서의 동등비교
- `Object.is` 로 비교한 다음, **얕은 비교**를 한번 더 수행
  - 얕은 비교는 첫번째 깊이에 존재하는 값만 비교

## 1.2 함수
### 1.2.4 함수를 만들 때 주의해야 할 사항
- 함수의 부수효과를 최대한 억제하라
  - 순수함수를 만들도록 노력할 것
  - 모든 부수효과를 없앨 수는 없지만, 최소한으로 줄여보자
    - 🌱 **참고할만한 예제**
      - [you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)
      
- 가능한 함수를 작게 만들어라
- 누구나 이해할 수 있는 이름을 붙여라

> 🌱 **함수형 프로그래밍**
> - 코드를 액션, 계산, 데이터를 나눠 작성하는 디자인 패턴 
> - 복잡한 비즈니스 로직을 정리하는데 첫걸음을 도와주는 패턴
> - [데이터 / 계산 / 액션 분리하기](https://summerr.tistory.com/130)

# 📚 2장 리액트 핵심 요소 깊게 살펴보기
### 2.1.1 JSX의 정의
**JSX**
- 리액트에서 UI를 표현하는데 사용됨.

**JSXElement**
- JSX를 구성하는 가장 작은 요소
> - 🌱 [함수형 컴포넌트의 리턴타입](https://medium.com/@gogosky1175/reactnode-reactelement-jsx-element%EC%9D%98-%EC%B0%A8%EC%9D%B4-30bfbd4ef4b7) 이며, 리액트의 요소를 나타내는 타입이다.

```typescript jsx
const Component = () => <Box>...</Box> // :JSX.Element
```

### 2.1.2 JSX 예제
```typescript jsx
<A.B>...</A.B>
```
- 🌱 **JSXMemberExpression** 활용 중, `.` 을 사용한 JSX문법은 주로 [CCP 패턴](https://patterns-dev-kr.github.io/design-patterns/compound-pattern/)으로 리액트 컴포넌트 설계시 사용됩니다.

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까
- JSX의 반환값은 React.createElement 값으로 귀결된다.

## 2.2 가상 DOM과 리액트 파이버

### 2.2.1 DOM과 브라우저 렌더링 과정
- 사용자가 브라우저로 사이트 접속
- 브라우저는 사이트 서버로부터 HTML 파일 다운로드
- 브라우저 렌더링 엔진은 다운받은 HTML 파일을 파싱해 DOM Tree를 구성한다
- CSS를 만나면 CSS파일도 다운로드 -> CSS Tree도 구성함
- DOM 노드 순회 : 눈에 보이는 요소만
- CSS 정보를 DOM요소에 적용
    - 레이아웃: 각 DOM이 브라우저의 어느 곳에 위치해야하는지 계산하는 과정 (레이아웃 이후엔 페인팅이 일어남)
    - 페인팅: 실제 그리는 과정

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버
- 가상 DOM과 렌더링 과정 최적화를 가능하게 해줌

- 파이버는 리액트에서 관리하는 자바스크립트 객체
  - 가상 DOM과 실제 DOM을 비교해 변경사항을 수집
  - 이 둘 사이에 차이가 있으면 파이버를 기준으로 화면에 렌더링 요청을 함

- **Reconciliation**
  - 가상돔과 실제돔을 비교하는 알고리즘

## 2.4 렌더링은 어떻게 일어나는가

### 2.4.1 리액트에서의 렌더링
- 브라우저가 렌더링에 필요한 DOM Tree를 만드는 과정
- 모든 컴포넌트들이 현재 자신들이 가지고 있는 Props와 State의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정


### 2.4.2 리액트의 렌더링이 일어나는 이유
- 최초 렌더링
- 리렌더링
  - useState
    - setter를 실행해 side effect 를 일으킬 경우
  - key props가 변경될 경우
    - 형제요소들 사이에서 식별할 수 있게 해주는 값
      - 변경이 일어나는 요소인 경우 key 가 필수
  - **부모 컴포넌트에 렌더링이 일어날 경우**

### 2.4.4 렌더와 커밋
- 렌더단계: 컴포넌트를 렌더하고 변경 사항을 계산하는 모든 작업
- 커밋단계: 렌더단계 변경사항을 실제 DOM에 적용 -> 이 단계가 끝나야 브라우저 렌더링이 일어남.

**리액트의 렌더링이 일어난다고 해서 무조건 DOM업데이트가 일어나는 것은 아니다.**
> 렌더단계에서 변경사항이 감지되지 않았거나, 커밋단계가 생략되는 경우

- 렌더링은 항상 동기식
- 렌더링 시간이 길어질 수록 애플리케이션의 성능 저하로 이루어짐

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션
### 2.5.1 필요한 곳에 메모이제이션을 추가하자
- 섣부른 최적화는 경계하자
- 이전 연산 결과를 저장하면 그거대로 메모리를 점유하게 됨
- 메모이제이션을 통한 성능개선이 렌더링보다 낫지 않다면 쓰지않는 것이 좋다

### 2.5.2 모조리 메모이제이션 하자
-- 얕은 비교가 일어나는 props의 변경의 비용이 크면 메모이제이션을 사용하는 것도 좋다.

> 🌱 최대한 메모이제이션을 쓰지 않고, 코드를 최적화 해보는 것이 어떨까?
> - 써야한다, 쓰지말아야 한다 갑론을박 토론에 한쪽에 치우쳐서 코드를 작성하는 것 보단,
> - 최대한 최적화할 수 있는 포인트를 찾아 개선해보는 것이 어떨까.
> - 선 최적화 -> 후 메모이제이션 
> - **메모이제이션을 쓰는 이유**
>   - 연산이 복잡해서 -> 복잡한 연산을 최적화 시도
>   - props의 변화가 자주 일어나서 -> props의 변화를 일으키는 side effect 최소화
>     - 사소한 포인트부터 개선해보자
>       - ex) 1. useState, useEffect 의존 최소화 [you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)
>       - ex) 2. SSOT [state의 변경은 한 컴포넌트에서 모두 처리하자](https://react-ko.dev/learn/sharing-state-between-components)
>       - ex) 3. 가벼운 form은 uncontrolled component나 react-hook-form 으로 교체해보자 [제어,비제어 컴포넌트](https://handhand.tistory.com/261), [리액트 form 데이터를 다룰 때 제어 컴포넌트와 비제어 컴포넌트를 선택하는 기준](https://careerly.co.kr/comments/75550)
>       - ex) 4. [불필요한 메모이제이션을 제거하는 원칙](https://d2.naver.com/helloworld/9223303)







